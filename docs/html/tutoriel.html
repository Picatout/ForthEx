<DOCTYPE! html>
<html lang="fr-CA">
<head>
<style>
p{
	margin-left:5%;
	width:90%;
}
hr{
	margin-left:5%;
	width:90%;
	border-width:4px;
}
div{
	margin-left:5%;
	width:90%;
	padding:5px;
}
textarea#code{
	align:left;
	min-width:40%;
    max-width:60%;
//    margin:auto;
    line-height:1.5;
    border-radius:4px;
    border:1px solid #F7E98D;
    margin:4px;
    font:13px Tahoma, cursive;
    font-smoothing:subpixel-antialiased;
    background-color:#F9EFAF;
    }
</style>
</head>
<body>
<h2>Présentation</h2>
<p>
	Ce tutoriel est structuré autour de la création d'un jeux vidéo simple, le classique 
	<a href="https://fr.wikipedia.org/wiki/Snake_(jeu_vid%C3%A9o)">Snake</a>. Il existe plusieurs variantes de ce jeu.
	Comme il s'agit d'un tutoriel sur le langage Forth, cette version sera la plus simple. 

</p>
<h3>règles du jeu</h3>
<p>
	<div><ol>
		<li>Le serpent ne doit pas entrer en collision avec la bordure de l'aire de jeu.</li>
		<li>Le serpent ne doit pas se mordre lui-même.</li>
		<li>Le serpent mange les pastilles qui apparaîssent dans l'aire de jeux.</li>
		<li>Le pointage est compté de la façon suivante:
		<ul>
			<li>Une pastille dans un coin compte pour 4 points.</li>
			<li>Une pastille le long d'un mur compte pour 2 points.</li>
			<li>Les autres pastilles comptent pour 1 point.</li>
		</ul></li>
		<li>Lorsque le serpent mange une pastille il s'allonge d'un anneau.</li>
		<li>Le serpent est toujours en mouvement mais sa direction est contrôlée par les touches <b>&larr;</b> et <b>&rarr;</b>.</li>
	</ol></div>
</p>
<h3>L'aire de jeux</h3>
<p>Le pourtour de l'écran est circonscris par une ligne blanche, le serpent est donc limité à une surface de 62 par 22 pixels. 
   Puisqu'il s'agit d'un écran texte, les pixels ici sont représentés par l'espace d'un caractère. Sur la première ligne de
   l'écran s'affiche le pointage <b>SCORE:</b>, et la longueur du serpent <b>LENGTH:</b>. Ces compteurs augmentent chaque fois qu'il mange.</p>
<h3>Analyse du programme.</h3>   
<p>Essayons de voir de quoi nous avons besoins pour réaliser ce jeux. Notez que le langage ForthEx est insensible à la casse. On peut écrire les 
identificateurs en minuscule,majuscules ou un mélange des deux. Les indentificateurs sont convertis en majuscules avant d'être ajouter au dictionnaire.</p>
<h4>Variables</h4>
<p>
	<div><ul>
		<li><b>SCORE</b>, Cette variable contient le pointage.</li>
		<li><b>SNAKE-LEN</b>, Cette variable indique la longueur du serpent.</li>
		<li><b>SNAKE</b>, Le corps du serpent doit-être représenté par un tableau (vecteur). Chaque élément de ce tableau
		contient les coordonnées de chaque caractère qui consistuent le corps du serpent.</li>
		<li><b>HEAD</b>, Cette variable indique la direction de déplacement de la tête du serpent. Nous voulons que la tête
		du serpent ressemble à une bouche ouverte, nous allons donc utiliser un caractère différent pour chaque direction.
		<table border="single">
			<tr><th>direction</th><th>valeur</th><th>car. tête</th></tr>
			<tr><td>est</td><td>0</td><td>&lt;</td></tr>
			<tr><td>sud</td><td>1</td><td>W</td></tr>
			<tr><td>ouest</td><td>2</td><td>&gt;</td></tr>
			<tr><td>nord</td><td>3</td><td>M</td></tr>
		</table>
		</li>
		<li><b>C-HEAD</b>, Il s'agit d'un tableau de 4 caractères qui va nous permettre d'obtenir le caractère à afficher
		pour la tête en fonction de la direction. On obtiendra le bon caractère en indiçant le tableau avec la valeur de la variable
	    <b>HEAD</b>.</li>
	    <li><b>FOOD</b>, Cette variable contient les coordonnées de la pastille de nourriture. Lorsque la pastille est avalée par le serpent
	    les coordonnées sont remises à {0,0}.</li>
	    <li><b>TAIL</b>, Nous avons besoin de savoir où était le dernier anneau du serpent avant son dernier déplacement.
	    Cette information va nous permettre d'effacer cet anneau après le déplacement ou d'allonger le serpent lorsqu'il mange.</li>
	</ul></div>
</p>   
<p>
	Le corps du serpent et les pastilles de nourritures seront représentés par le caractère <b>O</b>.<br>
	Dans cette version simple du jeux le serpent va toujours se déplacer à la même vitesse. Le délais de boucle sera donc déterminé
	par la constante <b>SPEED</b>.
</p>
<h3>Déroulement du progamme (algorithme)</h3>
<p>
	<div><ol>
		<li>Déclaration des constantes.</li>
		<li>Déclaration des variables.</li>
		<li>Initialisation d'une partie:
		<ul>
			<li>Initialisation des variables.</li>
			<li>Création du serpent initial.</li>
			<li>Dessin des murs.</li>
		</ul>
		</li>
		<li>Boucle de la partie:
		<ol>
			<li>Afficher le status.</li>
			<li>S'il n'y a pas de pastille dans l'aire de jeux en créer une.</li>
			<li>Afficher la pastille.</li>
			<li>déplacer le serpent d'un pas.</li>
			<li>Dessiner le serpent à sa nouvelle position.</li>
			<li>Si le serpent a avalé la pastille ajuster le pointage et la longueur.</li>
			<li>Sinon vérification collision, si collision terminer partie.</li>
			<li>Délais vitesse déplacement.</li>
			<li>Lire clavier, si touche <i>flèche-gauche</i> ou <i>flèche-droite</i> modifier variable HEAD. Si <b>Q</b> quitter le jeu.</li>
			<li>Boucler à l'étape 1.</li>
		</ol>
		</li>
		<li>Signaler fin de la partie.</li>
		<li>Attendre touche pour intialiser la prochaine partie ou (Q)uitter.</li>
	</ol></div>
</p>  
<h2>La machine virtuelle Forth</h2>
<p>
	Le langage Forth donne accès à ses structures internes. Il faut donc que le programmeur Forth connaisse le fonctionnement interne, ce qu'on appelle
	la machine virtuelle. Nous allons donc décrire ici cette machine virtuelle.
</p>
<p>
	Il y a 2 piles que l'utilisateur doit manipuler, la pile des arguments et la pile des retours. Dans la plupart des langages comme le 
	<b>C</b> le programmeur n'a pas besoin de manipuler la pile, c'est le compilateur qui s'en occupe. En Forth c'est différent, vous devez connaître
	ces 2 piles et les mots Forth qui permettent de les manipuler. 
</p>
<h3>Pile des arguments</h3>
<p>
	La pile des arguments comme son nom l'indique sert à passer des arguments entre les fonctions et aussi à retourner les valeurs des fonctions. Une
	foncion peu retourner plus d'une valeur. En plus elle sert à garder les variables temporaires qui sont utilisées par la fonction. Ce n'est pas très
	différent du langage <b>C</b> sauf que pour ce dernier le programmeur n'a pas besoin de connaître ces détails. Une des difficultés du Forth est que
	justement vous devez garder en tête l'état le la pile des arguments mais aussi de la pile des retours dans certains cas. L'autre différence entre le
	<b>C</b> et Forth est qu'en <b>C</b> il n'y a qu'une seule pile pour les arguments et les retours.
</p>
<p> La pile des arguments utilise un pointeur nommé <b>SP</b> qui pointe sur l'élément au sommet de la pile. Il y a des mots comme <b>SP@</b> et 
<b>SP!</b> qui permettent de lire et initialiser la valeur de ce pointeur respectivement.</p>
<h3>Pile des retours</h3>
<p>
	La pile des retours est très semblable à ce qu'on retrouve dans d'autre langages comme le <b>C</b>. Sa fonction principale est de conserver les
	adresses de retour lors d'un appel de sous-routine. En plus de ce rôle on s'en sert aussi pour conserver certaines valeurs afin de faciliter 
	l'accès à des valeurs de la pile des arguments qui ne sont pas au sommet. Plusieurs mots servent à transférer des valeurs entre la pile des 
	arguments et la pile des retours.
</p>
<p> La pile des retours utilise un pointeur nommé <b>RP</b> qui lui pointe non pas sur la valeur au sommet de la pile mais sur le premier 
emplacement vide. Ceci est un détail de l'implémentation de ForthEx et n'affecte en rien l'utilisation des mots Forth. Il est quand même 
utile de savoir que le mot <b>RP@</b> retourne une adresse au dessus du sommet de la pile.</p>
<h3>Cellule</h3>
<p> Un mot qui revient souvent en Forth est le mot <b>CELL</b>, qui signifie <i>cellule</i>. La cellule est l'élément de base des données, c'est
à dire la taille élémentaire d'une donnée sur les piles. Habituellement les 2 piles ont la même taille de cellule. Pour ForthEx une cellule est 
un élément de 16 bits. Ça signifit que les opérations sur les piles se font sur des objets de 16 bits. Un entier ForthEx a 16 bits, un entier
double a 32 bits et occupe donc 2 cellules sur la pile. L'ordinateur ForthEx utilise aussi des pointeurs 16 bits, sauf pour l'accès à certains 
périphériques de stockages qui nécessitent des adresses de 32 bits. Dans ce cas on utilise un entier double pour les représentés.
</p>
<h3>Le dictionnaire</h3>
<p> L'autre élément fondamental du Forth est ce qu'on appelle le dictionnaire.  Le dictionnaire Conserve le nom de tous les symboles utilisés par
le langage, les opérateurs arithmétique, logiques, relationels, les fonctions, les variables et les constantes. À chacun des ces symboles est associé
un pointeur qui indique l'action qui doit-être exécutée lorsque ce nom est invoqué dans un programme où sur la ligne de commande interactive. Par exemple
si on invoque le nom d'une constante sa valeur est empilée au sommet de la pile des arguments. Si on invoque le nom d'une variable l'adresse de celle-ci
est empilée au sommet de la pile des arguments. Si on invoque le nom d'un opérateur arithmétique comme <b>+</b> cette opération est exécutée en utilisant
les 2 valeurs au sommet de la pile des arguments.
</p>
<h3>Constante et variables système</h3>
<p>
	La machine virtuelle ForthEx utilisent un certain nombre de constantes et variables qui sont accessible au programmeur nous les mentionnerons
	lors de leur utilisation.
</p>
<h2>La syntaxe Forth</h2>
<p> Je dirais que ce qui caractérise le plus le langage Forth est la simplicité de la syntaxe. Un programme Forth est simplement une liste de mots
séparés par un espace. L'interpréteur lit un mot et le cherche dans le dictionnaire, s'il le trouve il exécute immédiatement l'action qui est associé
à ce mot. Si le mot n'est pas dans le dictionnaire ce doit-être un entier (simple ou double) et dans ce cas l'interpréteur empile la valeur de cet entier.
L'interpréteur Forth est donc très simple: Lire le prochain mot, le chercher dans le dictionnaire, exécuter son action si trouvé sinon vérifier si c'est
un nombre et empiler ce nombre autrement arrêter et signaler une erreur.
</p>
<p>
	Lorsqu'on est en train de compiler une nouvelle définition dans le dictionnaire, la seule différence est que l'interpréteur compile l'adresse du code
	à exécuter au lieu de l'exécuter à moins qu'il s'agisse d'un mot <i>immédiat</i>. Les mots <i>immédiat</i> sont toujours exécutés immédiatement même
	lors d'une compilation. 
</p>
<h3> Les commentaires</h3>
<p> Il y a deux types de commentaires en Forth ceux introduit par le mot <b>(</b> et qui se termine par le délémiteur <b>)</b> et ceux qui sont 
    introduit par le mot <b>\</b> et qui se termine à la fin de la ligne. Notez que j'ai dit qu'il s'agissait de <b>mots Forth</b>. Ça signifit 
    qu'il faut qu'ils soient séparés par un espace de chaque côté.<br>
    <textarea id="code" style="height:100px;">
		\ ceci est un commentaire qui se termine à la fin de la ligne.
		\ceci génère une erreur, l'interpréteur va affiché: \ceci?
		( ceci est un commentaire qui se termine ici)
		(ceci génère une erreur, l'interpréteur va affiché: (ceci? 
    </textarea><br>
    Lorsque l'interpréteur ne trouve pas le mot dans le dictionnaire et que ce n'est pas un nombre il s'arrête en affichant le
    mot suivit d'un point d'interrogation.
</p>
<h3>Les indentifiants</h3>
<p>
	Puisqu'en Forth seul l'espace est utilisé comme séparateur de mot, un mot peut être formé avec n'importe quel caractère sauf l'espace.
	<br><textarea id="code" style="height:100px">
		&*/ \ ceci est un nom valide
		snake-len \ ça aussi il n'y a pas d'espace de
		\ chaque côté du '-' donc ce n'est pas un mot
		\ en lui-même.
	</textarea><br>
</p>
<h3>La notation préfixée.</h3>
<p> Autre particularité de la syntaxe Forth est que les arguments ( sauf exception ) sont énoncés avant la fonction. C'est ce qu'on appelle la
notation préfixée. exemple.
   <textarea id="code" style="height:100px;">
	   34 56 *  \ multipliation de 34 par 56
	   21 7 /  \ division de 21 par 7
	   12 7 2 - * \ en infixe donne 12*(7-2)
   </textarea>
</p>
<h3>Débutons le codage</h3>
<p>
	À ce point çi nous disposons suffisamment d'information pour débuter l'écriture du code. Si nous avons manquer un point nous nous ajusterons en
	cours de route. Mais d'abord il faut répondre à quelques questions.
	<div><ul>
	<li>Quel sera la longueur initiale du serpent? J'ai opté pour 4.</li>
	<li>Est-ce que le serpent a une position et une direction initiale fixes, où laissons-nous ça au hasard? J'ai décidé qu'il démarrait au
	centre de l'écran et se dirigeait vers l'est.</li>
	</ul></div>
	<div>
</p>
<p>
	Commençons donc à créer notre programme snake.<br>
	Définissons quelques constantes. Les constantes sont créées dans le dictionnaire avec le mot <b>CONSTANT</b>. On entre la valeur de la constante
	ensuite le mot <b>constant</b> suivit de sont nom. Une fois une constante créée il suffit d'invoquer son nom pur que sa valeur soit déposée au
	sommet de la pile des arguments.<br>
	<textarea id="code" style="height:220px;">
	128 constant max-len \ longueur maximale du serpent.
	\ directions des deplacements
	0 constant east
	1 constant south
	2 constant west
	3 constant north
	62 constant play-width \ largeur aire de jeu
	22 constant play-height \ hauteur aire de jeu
	2 constant x-offset \ décalage coordonnee X dans l'affichage
	2 constant y-offset \ décalage coordonnee Y dans l'affichage
	143 constant vk_left \ code touche fleche gauche
	144 constant vk_right \ code touche fleche droite	
	</textarea><br>
	Sans surprise les variables sont créées à l'aide du  mot <b>VARIABLE</b>. Lorsqu'une variable est invoquée c'est sont adresse qui est déposée
	au sommet de la pile. Ce qui permet de lire sa valeur avec le mot <b>@</b> ou bien de modifier cette valeur avec le mot <b>!</b>.<br>
	<textarea id="code" style="height:180px;">
	\ création des variables, elles sont inialisée à 0 lors de
	\ leur création.
	variable score \ pointage
	variable head \ direction serpent
	variable snake-len \ longueur serpent
	variable food \ localisation pastille nourriture
	variable tail \ localisation queue serpent
	</textarea>
</p>
<p>
	Il nous reste encore 2 variables à créer mais ces variables sont de type tableau (quoique je préfère le mot vecteur). Avant de créer ces 2 variables vecteurs
	je vais définir un mot particulier appellé <b>VECTOR</b>. Ce mot est un mot qui sert à créer une classe de mots,de la même manière que le mot 
	<b>VARIABLE</b> nous a permit de créer des objets de type <i>variable</i>, le mot <b>VECTOR</b> va nous permettre de créer des objets de type <i>vecteur</i>.
	<br>
	<textarea id="code" style="height:120px;">
		\ VECTOR va nous permettre de créer des 
		\ variables de type vecteur.
		\  cccc représente le prochain mot dans le texte d'entrée
		\ n est le nombre d'éléments du vecteur.
		: VECTOR ( cccc s: n -- )
		  CREATE CELLS ALLOT DOES&gt; SWAP CELLS + ;
    </textarea>
</p> 
<p>
	Dans ce tutoriel je vais appeller les mots qui servent à créer d'autres mots dans le dictionnaire <b>mots compilants</b>. <b>CONSTANT</b> <b>VARIABLE</b>,
	<b>:</b> et <b>CREATE</b> sont des <b>mots compilants</b>. Et maintenant que nous l'avons créé le mot <b>VECTOR</b> qui est aussi un <b>mot compilant</b>.
</p>
<p>
	Le premier mot que nous avons utiliser pour définir <b>VECTOR</b> est le mot <b>:</b> Ce mot cré une nouvelle entrée dans le dictionnaire qui porte
	le nom qui le suis dans le texte d'entrée. En l'occurence ici il s'agit du mot <B>VECTOR</B>. Il existe une variable système qui s'appelle <b>STATE</b>.
	Cette variable détermine l'action de l'interpréteur. Lorsque cette variable est à <b>0</b> l'interpréteur exécute immédiatement chaque mot qu'il lit dans le
	texte d'entrée. Mais lorsque <b>STATE</b> a la valeur <b>-1</b>, l'interpréteur compile dans le dictionnaire l'adresse du code d'action au lieu de
	l'exécuter. Le mot <b>:</b> après avoir créer une entrée dans le dictionnaire pour <b>VECTOR</b> change la valeur de <b>STATE</b> à <b>-1</b>. Donc tous
	les mots qui suivent le mot <b>VECTOR</b> seront compilés dans le dictionnaire à la suite du mot <b>VECTOR</b>. Il y a une exception. Les mots dits <i>
	immédiat</i> sont quand même exécutés lorsque STATE est à -1. dans la définition de <b>VECTOR</b> on utilise 2 mots immédiats <b>DOES&gt;</b>
	et <b>;</b>. Le mot <b>;</b> est utiliser pour terminer une définition, il sert simplement à remettre à <b>0</b> la valeur de <b>STATE</b>.
</p>
<p> Le mot <b>DOES&gt;</b> est plus complexe. Il termine la définition du mot <b>VECTOR</b> et compile une action qui va être exécutée par les mots créés avec
<b>VECTOR</b>. Autrement dit les mots créés par <b>VECTOR</b>, lorsqu'ils seront invoqués, vont exécuter le code:
<br><textarea id="code" > SWAP CELLS + </textarea> <br>
</p>
<p>
	Donc lorsque l'interpréteur à terminé la lecture du code ci-haut on a un nouveau mot dans le dictionnaire, <b>VECTOR</b> et on va s'en servir
	pour créer des variables de type <i>vecteur</i>. Voici ce qui se passe lorsqu'on invoque le mot <b>VECTOR</b>. Regardons la partie de sa 
	définition qui précède <b>DOES&gt;</b>.<br>
	<textarea id="code" >CREATE CELLS ALLOT</textarea><br>
	Seulement 3 mots.
	<ul>
		<li><b>CREATE</b>, Lit le prochain mot dans le texte d'entré et cré un nouveau mot dans le dictionnaire avec ce nom. Lorsqu'un mot
		qui a été créé par <b>CREATE</b> est invoqué son action est de déposé au sommet de la pile l'adresse du premier octet de donnée, ce
		qu'on appelle <b>PFA</b> pour <i>Parameter Field Address</i>.</li>
		<li><b>CELLS</b>, Multiplie la valeur qui est au sommet de la pile par le nombre d'octets d'une cellule. En ForthEx l'on l'a dit
		les cellules sont de 16 bits donc 2 octets. Donc la valeur au sommet de la pile est multipliée par 2.</li>
		<li><b>ALLOT</b>, Consomme la valeur au sommet de la pile des arguments et se sert de cette valeur pour réserver l'espace nécessaire 
		dans l'espace de données pour stocker le nombre d'octets indiqué par cette valeur.</li>
	</ul><br>
	<textarea id="code" style="height:180px;">
	\ creation des variables vecteur.		
	\ tableau de 4 car. representant la tete du serpent.
	4 vector c-head
	\ le corps du serpent.
	max-len vector snake
	
	\ initialiation de c-head
	'&lt;' east c-head !
	'W' south c-head !
	'&gt;' west c-head !
	'M' north c-head !
	</textarea><br>
	Prenons l'exemple de <b>C-HEAD</b>. On empile la valeur <b>4</b> qui sera consommé par <b>VECTOR</b> qui est invoqué à la suite de son
	argument suivit du nom de la <i>variable vecteur</i>, ici <b>C-HEAD</b>. Une fois que l'interpréteur a lu cette phrase il y a donc un 
	nouveau mot dans le dictionnaire appellé <b>C-HEAD</b>. l'initialisation de <b>C-HEAD</b> nous montre comment utiliser un vecteur.
	les vecteurs consomme 1 argument et en retourne 1. Notez la façon dont on documente les arguments d'un mot en Forth <b>( u -- a-addr )</b>.
	Lorsque vous lirez du code Forth vous verrez constamment ce type de commentaires. C'est une description abrégée de l'interface de la 
	fonction. Dans le cas qui nous concerne un <b>vecteur</b> consomme un entier non signé représenté par <b>u</b> et retourne 
	une adresse alignée sur une cellule représenté par <b>a-addr</b>.  La valeur de <b>u</b> indique quel élément du vecteur nous voulons 
	atteindre. Le permier élément d'un vecteur porte l'indice <b>0</b>, le deuxième l'indice <b>1</b>, etc. Prenons en exemple la phrase suivante:
	<br><textarea id="code">
	'&lt;' east c-head !	
	</textarea><br>
	Cette phrase comprend 4 mots, voyons ce qui se trouve sur la pile des arguments après l'exécution de chacun d'eux.<br>
	<table border="single">
	<tr><th>mot</th><th>description</th><th>État de la pile</th></tr>	
	<tr><td>'&lt;'</td><td>Il s'agit d'un entier de type caractère dont la valeur ASCII est 60.</td><td>60</td></tr>
	<tr><td>east</td><td>Il s'agit d'une constante ça valeur est empilée.</td><td>0<br>60<br</td></tr>
	<tr><td>c-head</td><td>Il s'agit d'un vecteur. Il consomme la valeur au sommet de la pile et le<br>
	remplace par l'adresse de cet élément.</td>
	<td>a-addr<br>60</td></tr>
	<tr><td>!</td><td>Ce mot consomme 2 valeurs sur la pile. Le premier est une adresse et<br>
	le deuxième élément est la valeur à déposer à cette adresse.</td><td><i>pile vide</i><br>maintenant c-head[0]=60</td></tr>
	</table>
</p>
<p> 
	Comment est calculé l'adresse de l'élément du vecteur? C'est justement la partie de la définition de <b>VECTOR</b> qui suis <b>DOES&gt;</b>
	qui fait ce travail. Lorsque le mot <b>C-HEAD</b> est invoqué l'adresse de son champ de données est déposé au sommet de la pile ensuite le
	code suivant est exécuté.<br>
	<table border="single">
	<tr><th>mot</th><th>description</th><th>État de la pile</th></tr>	
	<tr><td></td><td>Avant l'invocation de c-head on sur la pile</td><td>0<br>60</td></tr>
	<tr><td>c-head</td><td>Lorsque c-head est invoqué mais avant que le code DOES&gt;<br>
	ne soit exécuté on sur la pile.</td><td>pfa<br>0<br>60</td></tr>
	<tr><td>swap</td><td>Commute les 2 éléments au sommet de la pile.</td><td>0<br>pfa<br>60</td></tr>
	<tr><td>cells</td><td>Multiplie l'indice au sommet de la pile par 2.</td><td>2*0<br>pfa<br>60</td></tr>
	<tr><td>+</td><td>Additionne les 2 valeurs au sommet de la pile. a-addr=0+pfa</td><td>a-addr<br>60</td></tr>
	</table><br>
	Là on voulait accéder l'élément 0 du vecteur donc l'adresse n'a pas changée mais pour les autre éléments l'adresse est incrémentée de
	<b>2*i</b> où <b>i</b> est l'indice qu'on veut accéder. 
</p>
<p>
	Notez ici combien il est important lorsqu'on programme en Forth de connaître se qu'il y a sur la pile des arguments ou même des retours si on
	utilise cette dernière pour conserver des valeurs temporairement. On peut s'aider à l'aide de commentaires qui indique les valeurs sur
	la pile des arguments par une liste précédé de <b>S:</b> et <b>R:</b> pour la pile des retours. Voici un exemple de commentaire.
	<br><textarea id="code" style="height:100px;">
	4 3 \ après avoir empilé 4 et 3 on a S: 4 3
	>r  \ après avoir transféré T sur R on a S: 4  R: 3
	drop r> \ après avoir jeté T et transféré R sur S on S: 3 R:
	</textarea><br>
	Pour comprendre cet exemple il faut savoir qu'on nomme le sommet de la pile des arguments <b>T</b> et que le mot <b>&gt;R</b> 
	transfert le sommet de la pile des arguments vers la pile des retour et que
	le mot <b>R&gt;</b> fait exactement le contraire. Tandis que le mot <b>DROP</b> jette la valeur au sommet de la pile des arguments.
</p>
<h3>Premiers mots du jeu</h3>
<p>
	On va maintenant définir quelques mots qui seront utilisés dans les graphismes du jeu.<br>
	<textarea id="code" style="height:500px;">
	\ fonctions graphiques
	\ conversion entier non signe vers couple {x,y}
	: ucoord>xy ( u -- x y )
	   256 /mod ;
	\ conversion couple {x,y} vers ucoord
	: xy>ucoord ( x y -- u )
	   256 * + ;
	\ dessine un pixel  c caractere {x,y} coord.
	: draw-pixel ( c x y -- )
	   y-offset + swap x-offset + swap at-xy emit ;
	\ dessine une pastille u=ucoord
	: draw-ring ( u -- )
	   true b/w
	   'O' swap ucoord>xy draw-pixel false b/w ;
	\ dessine les bandes de l'arene
	: draw-walls ( -- )
	   cls 1 whiteln 24 whiteln
	   24 2 do 1 i at-xy space 64 i at-xy space loop false b/w ;

	\ jeu serpent
	\ dessine le serpent
	: draw-snake ( -- )
	   head @ c-head @ 0 snake @ ucoord>xy draw-pixel
	   snake-len @ 1 do i snake @ draw-ring loop ;

	\ dessine pastille nourriture
	: draw-food ( -- )
	   true b/w 'O' food @ ucoord>xy
	   draw-pixel false b/w ;

	\ déplace le serpent dans la direction
	\ indiquée par la variable HEAD.
	: move-snake ( -- )
	   0 snake @ dup ucoord>xy
	   head @ case
		   east of swap 1+ swap endof
		   south of 1+ endof
		   west of swap 1- swap endof
		   north of 1- endof
		   endcase xy>ucoord
	   0 snake !
	   snake-len @ 1 do i snake dup >r @ swap r> !
	   loop dup tail !
	   bl swap ucoord>xy draw-pixel draw-snake ;

	\ affiche le status
	: status ( -- )
	   true b/w 1 1 at-xy s" SCORE:" type score @ .
	   16 1 at-xy s" LENGTH:" type snake-len @ . false b/w ;

	</textarea><br>
	Comme on le voie ici, chaque nouvelle définition de fonction commence par le mot <b>:</b> et se termine par le mot <b>;</b>. Après chaque nom 
	de fonction on retrouve un commentaire en parenthèse qui spécifie en abrégé l'interface de chaque fonction. Les coordonnées de chaque élément du
	jeu seront conservées dans un entier non signé représenté par un <b>u</b> dans les commentaires d'interface. Si on prend le mot <b>ucoord>xy</b>
	en exemple, le commentaire nous dit que ce mot consomme un entier non signé et nous retourne un couple d'entier notés <b>x y</b> qui représente
	la position de l'élément à l'écran. Le coin supérieur gauche de l'aire de jeu a les coordonnées {0,0} et le coin inférieur droit {62,22}.
	La conversion est simple puisque la coordonnée <b>y</b> est conservée dans l'octet fort de l'entier et la coordonnée <b>x</b> dans l'octet faible.
	Le mot <b>/mod</b> divise un entier et conserve le quotient et le reste. Le quotient est au sommet de la pile et le reste en deuxième position.
	Donc après l'exécution de la phrase <b>256 /mod</b>, l'entier <b>u</b> est remplacé par <b>x y</b>. 
</p>
<p>
	Le mot <b>xy>ucoord</b> fait exactement le contraire il convertie le couple <b>x y</b> en entier non signé <b>u</b>. Comme indiqué dans le 
	commentaire entre parenthèses. Encore une fois l'opération est simple on multiplit <b>y</b> par 256 et on additionne <b>x</b> à ce résultat.
</p>
<p> Le mot <b>draw-pixel</b> affiche le caractère <b>c</b> à la position <b>x y</b> de l'aire de jeu. Le mot <b>at-xy</b> est un mot standard du
Forth qui sert à positionner le curseur texte sur l'écran de la console. Cependant en ForthEx les coordonnées d'écran sont {1,1} pour le coin 
supérieur gauche et {64,24} pour le coin inférieur droit. On a donc définit les constantes <b>x-offset</b> et <b>y-offset</b> pour ajuster les
coordonnées de l'aire de jeu aux coordonnées réelles de l'écran de la console. On commence donc par ajuster la coordonnée <b>y</b> ensuite pour
ajuster la coordonnée <b>x</b> on doit commuter les positions de <b>x</b> et <b>y</b> sur la pile pour que <b>x</b> passe au sommet. C'est ce que
fait le mot <b>swap</b>. <b>x-offset +</b> ajuste la valeur de x et le deuxième <b>swap</b> remet les coordonnées dans le bon ordre avant 
d'invoquer <b>at-xy</b>. Le mot <b>emit</b> sert à afficher le caractère <b>c</b> (en 3ième position sur la pile) à l'écran.
</p>
<p> Le mot <b>draw-ring</b> est utilisé pour dessiner le corps du serpent et la pastille de nourriture. Les 2 étant représenté par le même caractère
 en inverse vidéo.  En ForthEx les valeurs booléennes VRAI et FAUX sont représentées par 2 constantes <b>TRUE</b> qui vaut <b>-1</b> et <b>FALSE</b>
 qui vaut <b>0</b>. Cependant Toute valeur différente de <b>0</b> est considérée comme VRAI. Le mot <b>b/w</b> signifit black/white et sert a 
 inverser l'affichage des caractères. Il consomme un valeur une booléenne. Si cette valeur est vrai les caractères sont affichés en inverse vidéo,
 c'est à dire noir/blanc. Au contraire si cette valeur est fausse on revient à l'affichage normal. Donc au début de <b>draw-ring</b> on passe en
 inverse vidéo pour afficher le caractère <b>O</b> aux coordonnées spécifiées par le paramètre <b>u</b> qui est au sommet de la pile. <b>swap</b>
 comme on la vue précédemment commute 2 les valeur au sommet de la pile de sorte que le <b>O</b> qu'on vient d'empiler se retrouve en deuxième position
 et que le <b>u</b> se retrouve au sommet. On utilise <b>ucoord>xy</b> pour convertir cet entier en couple <b>x y</b> qui est requis par <b>draw-pixel.</b>
 Avant de quitter <b>draw-ring</b> on remet l'affiche en mode normal avec la phrase <b>false b/w.</b>
</p>	
<p> Le mot <b>draw-walls</b> dessine la bordure qui délimite l'aire du jeu. le mot <b>cls</b> vide l'écran de la console. <b>1 whiteln</b> dessine 1
ligne blanche à la position y qui lui est fournie. Ici 2 lignes blanche sont dessinées en haut et en bas de l'écran. Pour dessiner les lignes verticales
à droite et à gauche de l'écran on utilise une boucle avec compteur <b>DO ... LOOP</b>.  Entre le mot <b>do</b> et le mot <b>loop</b> se sont les 
instructions qui s'exécutent en bloucle.Le mot <b>DO</b> consomme 2 arguments, <b>24</b> est la limite du compteur et  <b>2</b> est la valeur initiale 
du compteur. On a déjà vu le mot <b>at-xy</b> qui consomme 2 arguments, soit les coordonnées colonne et ligne où doit-être positionner le curseur texte. 
le mot <b>i</b> sert à empiler la valeur du compteur de boucle. Les instructions de la boucle commence donc par empiler la valeur <b>i</b> ensuite la 
la valeur du compteur de boucle, dont la valeur est 2 à la première itération. On positionne le curseur et on affiche un caractère espace en invoquant le
mot <b>space</b>. Comme on est en inverse vidéo cet espace apparaît comme un carré blanc. On recommence l'opération à la colonne <b>64</b> et on arrive à 
<b>loop</b> qui incrémente le compteur pour ensuite le comparé à la limite. Si cette limite est atteinte l'exécution continue après le <b>loop</b> sinon
on retourne après le <b>do</b>. Donc ici puisque <b>do</b> a été initialisé avec une limite de <b>24</b> le traçage des lignes verticales se termine à la
ligne 23.
</p>
<p> <b>draw-food</b> sert à dessiner la pastille de nourriture en inverse vidéo. La position de la pastille est conservée dans la variable <b>food.</b>
 Donc après être passé en mode vidéo inverse par la phrase <b>true b/w</b> on obtient la position par la phrase <b>food @</b>, on convertit l'entier
 en couple x,y avec <b>ucoord&gt;xy</b> avant d'appeller <b>draw-pixel</b>. Pour conclure on repasse en vidéo normal avec <b>false b/w.</b>
</p>
<p>Le mot <b>draw-snake</b> sert à dessiner le serpent. On commence par dessiner la tête. Comme on l'a dit le caractère utilisé pour la tête dépend de la
direction du mouvement du serpent. Cette direction est indiquée par la valeur de la variable <b>HEAD</b>. On lit donc cette valeur avec la phrase
<b>head @</b> et cette valeur sert d'indice pour aller chercher le bon caractère dans le vecteur <b>c-head</b> par la phrase <b>c-head @</b>. Ensuite on
obtient la position de la tête du serpent avec la phrase <b>0 snake @</b> et on dessine la tête avec la phrase <b>ucoord&gt;xy draw-pixel.</b> Pour dessiner
le corps du serpent on utilise encore une boucle <b>do...loop</b>. Cette boucle est initialisée avec la longueur du serpent qu'on obtient avec la phrase
<b>snake-len @</b> et l'indice de départ est <b>1</b> puisqu'on a déjà dessiner la tête. la phrase <b>i snake @</b> nous donne la coordonnée de l'ième 
élément du serpent et <b>draw-ring</b> dessine l'anneau. Et bien sur <b>loop</b> incrémente le compteur et nous renvoie au début de la boucle tant qu'on
a pas atteint la limite.
</p>
<p>Le mot <b>move-snake</b>, qui sert à déplacer le serpent, est plus complexe que les précédent. Je vais donc commencer par expliquer comment on déplace le
serpent avant d'examiner le code qui effectue cette action.
<ol>
	<li>La variable <b>head</b> nous indique dans qu'elle direction on doit déplacer le serpent. Selon la valeur de <b>head</b> on doit:
	<table border="single">
		<tr><th>head</th><th>modification</th></tr>
		<tr><td>est</td><td>x=x+1</td></tr>
		<tr><td>sud</td><td>y=y+1</td></tr>
		<tr><td>ouest</td><td>x=x-1</td></tr>
		<tr><td>nord</td><td>y=y-1</td></tr>
	</table>
	</li>
	<li>Le corps du serpent suis la tête çe qui signifit qu'une fois que la tête a été déplacée le premier anneau va à la position précédente
	de la tête. Le deuxième anneau à la position précédente du premier anneau, ainsi de suite jusqu'à la queue du serpent.</li>
	<li>Il s'agit donc de déplacer la tête en premier pour ensuite utiliser une boucle <b>do...loop</b> pour déplacer le reste du serpent.</li>
</ol>
	On commence donc par lire la valeur <i>ucoord</i> de la tête du serpent avec la phrase <b>0 snake @</b>. <b>dup</b>fait une copie de cette valeur
	car nous aurons besoin de cette valeur pour l'affecter au premier anneau du serpent. On transforme l'entier en couple <b>x,y</b> avec <b>ucoord&gt;xy</b>.
</p>
<h4>CASE</h4>
<p> Voici comment fonctione le <b>CASE</b> en Forth. Le <b>CASE</b> sert à sélectionner un choix multiple en comparant la valeur au sommet de la pile
avec différentes valeurs de contrôles. Ici la valeur au sommet de la pile est la direction obtenue par <b>head @</b>. Après le <b>case</b> suis la liste
des valeurs de contrôle. Dans ce cas ci, il s'agit des constantes <b>east, south, west et north</b>. Le mot <b>of</b> suis chaque valeur de contrôle et
est lui-même suivit du code à exécuter si la valeur de contrôle est égale à la valeur au sommet de la pile. <b>endof</b> indique la fin du code pour
cette condition. Il y a autant de <b>x of .... endof</b> qu'il y a de valeurs à contrôler. Le mot <b>endcase</b> termine le <b>case</b> en retirant
du sommet de la pile la valeur utilisée par <b>case</b>. Si aucune condition n'est rencontrée on peut insérer entre le dernier <b>endof</b> et 
<b>endcase</b> du code qui sera exécuté par défaut. <b>Attention</b>, si le code par défaut laisse une valeur sur la pile il doit faire un <b>swap</b>
pour ramené la valeur utilisée par <b>case</b> au sommet pour que celle-ci soit jetée par <b>endcase</b>.
</p>
<p> Maintenant que les coordonnées de la tête ont étées modifiées à l'intérieur du <b>case</b> on reconvertie le couple <b>x,y</b> en <i>ucoord</i>
avant de sauvegarder cette nouvelle valeur dans l'élément 0 du vecteur <b>snake</b> par la prhase <b>xy&gt;ucoord 0 snake !</b>.
</p>
<p>A ce point ci il nous reste au sommet de la pile l'ancienne <i>ucoord</i> de la tête. On commence une boucle pour déplacer le reste du serpent.
<b>snake-len @ 1 do</b>. Le code à l'intérieur du <b>do...loop</b> est en fait simple à comprendre. Pour chaque élément <b>i</b> du vecteur snake,
on commence par lire la valeur actuelle, on commute les 2 éléments au sommet de la pile et on sauvegarde la valeur qui est maintenant au sommet dans
cet ième élément. <b>dup &gt;r</b> sert simplement à conserver une copie de l'adresse du ième élément sur la pile des retours pour ensuite récupérer cette
adresse avec <b>r&gt;</b> lorsque viens le temps d'enregistrer la nouvelle valeur <i>ucoord</i> de cet élément. Gardez en tête qu'au début de chaque boucle
la valeur qui est au sommet de la pile des arguments est la position avant déplacement de l'élément précédent du serpent. Action à l'intérieur de la boucle:
<br><b>i snake dup &gt;r @ swap r&gt; !</b><br><table border="single">
<tr><th>action</th><th>S:</th><th>R:</th><th>commentaire</th></tr>
<tr><td></td><td>ucoord</td><td></td><td>juste avant de débuter le do...loop<br>on a sur la pile<br>l'ancienne position de la tête.</td></tr>	
<tr><td>i</td><td>compteur-boucle<br>ucoord</td><td></td><td>Le compteur de boucle débute à 1</td></tr>
<tr><td>snake</td><td>a-addr(i)<br>ucoord</td><td></td><td>Maintenant au sommet de la pile<br>on a l'adresse du ième élément du vecteur snake.</td></tr>
<tr><td>dup</td><td>a-addr(i)<br>a-addr(i)<br>ucoord</td><td></td><td>On a créer une copie de l'adresse.</td></tr>
<tr><td>&gt;r</td><td>a-addr(i)<br>ucoord</td><td>a-addr(i)</td><td>On envoie la copie sur la pile des retours.</td></tr>
<tr><td>@</td><td>ucoord-i<br>ucoord</td><td>a-addr(i)</td><td>Maintenant on a au sommet de S: <i>ucoord</i> du ième élément.</td></tr>
<tr><td>swap</td><td>ucoord<br>ucoord-i</td><td>a-addr(i)</td><td>On a commuter les 2 éléments au sommet de S:</td></tr>
<tr><td>r&gt;</td><td>a-addr(i)<br>ucoord<br>ucoord-i</td><td></td><td>On a ramené l'adresse du ième élément sur S:</td></tr>
<tr><td>!</td><td>ucoord-i</td><td></td><td>On a sauvegarder la valeur de l'élément (i-1) dans l'élément (i)<br>
et conserver l'ancienne valeur de l'élément (i) au sommet de S:</td></tr>
</table><br>
Lorsqu'on quitte la boucle <b>do...loop</b> il reste au sommet de la pile <i>l'ucoord</i> de la queue du serpent avant déplacement. On doit faire 2 
choses avec cette valeur. Premièrement on cré une copie et on la conserve dans la variable <b>tail</b>, <b>dup tail !</b>. Ensuite on va effacer
L'anneau qui se trouve à cette position puisque le serpent s'est déplacé il n'y a plus rien à cette coordonnée. <b>bl swap ucoord&gt;xy draw-pixel</b>.
Finalement on appelle <b>draw-snake</b> pour redesssiner le serpent au complet à sa nouvelle position.
</p>
<p>Pourquoi conserve-t'on l'ancienne position du dernier à anneau du serpent dans tail?  Parce qu'au moment où on déplace le serpent on ne sais pas
encore si le serpent a avalé la pastille de nourriture. Lorsqu'on va faire cette vérification et dans l'éventualité ou on doit rallonger le serpent
on va dessiner le nouvel anneau à cette position.
</p>
<p> Le mot <b>status</b> sert à afficher l'état du jeu, soit le pointage et la longueur du serpent. Cette affichage est présenté sur la première ligne
de l'écran en inverse vidéo, le mot commence donc par la phrase <b>true b/w</b> puis la phrase <b>1 1 at-xy</b> déplace le curseur dans le coin supérieur
gauche de l'écran.  La phrase <b>s" SCORE:" type</b> affiche le texte entre guillemets. On obtient le pointage par la lecture de la variable <b>score</b>
et on imprime cette valeur à la position courante du curseur texte avec le mot <b>.</b> En Forth le mot <b>.</b> <i>(point)</i> sert à imprimer l'entier 
qui se trouve au sommet de la pile. Ensuite on déplace le curseur texte à la colonne 16, ligne 1 avec la phrase <b>16 1 at-xy</b> et imprime le texte 
<i>LENGHT:</i> avec la phrase <b>s" LENGTH:" type</b>. Finalement on affiche la longueur du serpent avec la phrase <b>snake-len @ .</b>. Avant de 
quitter on repasse en mode vidéo normal <b>false b/w</b>.
</p>
<h3>La logique du jeu</h3>
<P>On va commencer à examiner les mots qui construisent la logique du jeu.</P>
</body>
</html>
	
