<DOCTYPE! html>
<html lang="fr-CA">
<head>
<style>
p{
	margin-left:5%;
	width:90%;
}
hr{
	margin-left:5%;
	width:90%;
	border-width:4px;
}
div{
	margin-left:5%;
	width:90%;
	padding:5px;
}
textarea#code{
	margin: 10px;
	padding: 5px;
	align:left;
	min-width:40%;
    max-width:60%;
    line-height:1.5;
    border-radius:4px;
    border:1px solid #F7E98D;
    font:13px Tahoma, cursive;
    font-smoothing:subpixel-antialiased;
    background-color:#F9EFAF;
    }
table,th,td{
	border:1px solid black;
	margin-top:5px;
	margin-bottom:5px;
}    
</style>
</head>
<body>
<h2>Présentation</h2>
<p>
	Ce tutoriel est structuré autour de la création d'un jeux vidéo simple, le classique 
	<a href="https://fr.wikipedia.org/wiki/Snake_(jeu_vid%C3%A9o)">Snake</a>. Il existe plusieurs variantes de ce jeu.
	Comme il s'agit d'un tutoriel sur le langage Forth, cette version sera la plus simple. 

</p>
<p> Il est préférable de lire la <a href="presentation.html">présentation du projet ForthEx</a> avant de lire ce tutoriel
ainsi que les 4 premiers paragraphes de l'<a href="index.html">index principal</a>.
</p>
<h3>règles du jeu</h3>
<p>
	<div><ol>
		<li>Le serpent ne doit pas entrer en collision avec la bordure de l'aire de jeu.</li>
		<li>Le serpent ne doit pas se mordre lui-même.</li>
		<li>Le serpent mange les pastilles qui apparaîssent dans l'aire de jeux.</li>
		<li>Le pointage est compté de la façon suivante:
		<ul>
			<li>Une pastille dans un coin compte pour 4 points.</li>
			<li>Une pastille le long d'un mur compte pour 2 points.</li>
			<li>Les autres pastilles comptent pour 1 point.</li>
		</ul></li>
		<li>Lorsque le serpent mange une pastille il s'allonge d'un anneau.</li>
		<li>Le serpent est toujours en mouvement mais sa direction est contrôlée par les touches <b>&larr;</b> et <b>&rarr;</b>.</li>
	</ol></div>
</p>
<h3>L'aire de jeux</h3>
<p>Le pourtour de l'écran est circonscris par une ligne blanche, le serpent est donc limité à une surface de 62 par 22 pixels. 
   Puisqu'il s'agit d'un écran texte, les pixels ici sont représentés par l'espace d'un caractère. Sur la première ligne de
   l'écran s'affiche le pointage <b>SCORE:</b>, et la longueur du serpent <b>LENGTH:</b>. Ces compteurs augmentent chaque fois qu'il mange.</p>
<h3>Analyse du programme.</h3>   
<p>Essayons de voir de quoi nous avons besoins pour réaliser ce jeux. Notez que le langage ForthEx est insensible à la casse. On peut écrire les 
identificateurs en minuscule,majuscules ou un mélange des deux. Les indentificateurs sont convertis en majuscules avant d'être ajouter au dictionnaire.</p>
<h4>Variables</h4>
<p>
	<div><ul>
		<li><b>SCORE</b>, Cette variable contient le pointage.</li>
		<li><b>SNAKE-LEN</b>, Cette variable indique la longueur du serpent.</li>
		<li><b>SNAKE</b>, Le corps du serpent doit-être représenté par un tableau (vecteur). Chaque élément de ce tableau
		contient les coordonnées de chaque caractère qui consistuent le corps du serpent.</li>
		<li><b>HEAD</b>, Cette variable indique la direction de déplacement de la tête du serpent. Nous voulons que la tête
		du serpent ressemble à une bouche ouverte, nous allons donc utiliser un caractère différent pour chaque direction.
		<table border="single">
			<tr><th>direction</th><th>valeur</th><th>car. tête</th></tr>
			<tr><td>est</td><td>0</td><td>&lt;</td></tr>
			<tr><td>sud</td><td>1</td><td>W</td></tr>
			<tr><td>ouest</td><td>2</td><td>&gt;</td></tr>
			<tr><td>nord</td><td>3</td><td>M</td></tr>
		</table>
		</li>
		<li><b>C-HEAD</b>, Il s'agit d'un tableau de 4 caractères qui va nous permettre d'obtenir le caractère à afficher
		pour la tête en fonction de la direction. On obtiendra le bon caractère en indiçant le tableau avec la valeur de la variable
	    <b>HEAD</b>.</li>
	    <li><b>FOOD</b>, Cette variable contient les coordonnées de la pastille de nourriture. Lorsque la pastille est avalée par le serpent
	    les coordonnées sont remises à {-1,-1}.</li>
	    <li><b>TAIL</b>, Nous avons besoin de savoir où était le dernier anneau du serpent avant son dernier déplacement.
	    Cette information va nous permettre d'effacer cet anneau après le déplacement ou d'allonger le serpent lorsqu'il mange.</li>
	</ul></div>
</p>   
<p>
	Le corps du serpent et les pastilles de nourritures seront représentés par le caractère <b>O</b> en inverse vidéo.<br>
	Dans cette version simple du jeux le serpent va toujours se déplacer à la même vitesse. Le délais de boucle sera donc déterminé
	par la constante <b>SPEED</b>.
</p>
<h3>Déroulement du progamme (algorithme)</h3>
<p>
	<div><ol>
		<li>Déclaration des constantes.</li>
		<li>Déclaration des variables.</li>
		<li>Initialisation d'une partie:
		<ul>
			<li>Initialisation des variables.</li>
			<li>Création du serpent initial.</li>
			<li>Dessin des murs.</li>
		</ul>
		</li>
		<li>Boucle de la partie:
		<ol>
			<li>Afficher le status.</li>
			<li>S'il n'y a pas de pastille dans l'aire de jeux en créer une.</li>
			<li>Afficher la pastille.</li>
			<li>déplacer le serpent d'un pas.</li>
			<li>Dessiner le serpent à sa nouvelle position.</li>
			<li>Si le serpent a avalé la pastille ajuster le pointage et la longueur.</li>
			<li>Sinon vérification collision, si collision terminer partie.</li>
			<li>Délais vitesse déplacement.</li>
			<li>Lire clavier, si touche <i>flèche-gauche</i> ou <i>flèche-droite</i> modifier variable HEAD. Si <b>Q</b> quitter le jeu.</li>
			<li>Boucler à l'étape 1.</li>
		</ol>
		</li>
		<li>Signaler fin de la partie.</li>
		<li>Attendre touche pour intialiser la prochaine partie ou (Q)uitter.</li>
	</ol></div>
</p>  
<h2>La machine virtuelle Forth</h2>
<p>
	Le langage Forth donne accès à ses structures internes. Il faut donc que le programmeur Forth connaisse le fonctionnement interne, ce qu'on appelle
	la machine virtuelle. Nous allons donc décrire ici cette machine virtuelle.
</p>
<p>
	Il y a 2 piles que l'utilisateur doit manipuler, la pile des arguments et la pile des retours. Dans la plupart des langages comme le 
	<b>C</b> le programmeur n'a pas besoin de manipuler la pile, c'est le compilateur qui s'en occupe. En Forth c'est différent, vous devez connaître
	ces 2 piles et les mots Forth qui permettent de les manipuler. 
</p>
<h3>Pile des arguments</h3>
<p>
	La pile des arguments comme son nom l'indique sert à passer des arguments entre les fonctions et aussi à retourner les valeurs des fonctions. Une
	foncion peu retourner plus d'une valeur. En plus elle sert à garder les variables temporaires qui sont utilisées par la fonction. Ce n'est pas très
	différent du langage <b>C</b> sauf que pour ce dernier le programmeur n'a pas besoin de connaître ces détails. Une des difficultés du Forth est que
	justement vous devez garder en tête l'état le la pile des arguments mais aussi de la pile des retours dans certains cas. L'autre différence entre le
	<b>C</b> et Forth est qu'en <b>C</b> il n'y a qu'une seule pile pour les arguments et les retours.
</p>
<p> La pile des arguments utilise un pointeur nommé <b>SP</b> qui pointe sur l'élément au sommet de la pile. Il y a des mots comme <b>SP@</b> et 
<b>SP!</b> qui permettent de lire et initialiser la valeur de ce pointeur respectivement.</p>
<h3>Pile des retours</h3>
<p>
	La pile des retours est très semblable à ce qu'on retrouve dans d'autre langages comme le <b>C</b>. Sa fonction principale est de conserver les
	adresses de retour lors d'un appel de sous-routine. En plus de ce rôle on s'en sert aussi pour conserver certaines valeurs afin de faciliter 
	l'accès à des valeurs de la pile des arguments qui ne sont pas au sommet. Plusieurs mots servent à transférer des valeurs entre la pile des 
	arguments et la pile des retours.
</p>
<p> La pile des retours utilise un pointeur nommé <b>RP</b> qui lui pointe non pas sur la valeur au sommet de la pile mais sur le premier 
emplacement vide. Ceci est un détail de l'implémentation de ForthEx et n'affecte en rien l'utilisation des mots Forth. Il est quand même 
utile de savoir que le mot <b>RP@</b> retourne une adresse au dessus du sommet de la pile.</p>
<h3>Cellule</h3>
<p> Un mot qui revient souvent en Forth est le mot <b>CELL</b>, qui signifie <i>cellule</i>. La cellule est l'élément de base des données, c'est
à dire la taille élémentaire d'une donnée sur les piles. Habituellement les 2 piles ont la même taille de cellule. Pour ForthEx une cellule est 
un élément de 16 bits. Ça signifit que les opérations sur les piles se font sur des objets de 16 bits. Un entier ForthEx a 16 bits, un entier
double a 32 bits et occupe donc 2 cellules sur la pile. L'ordinateur ForthEx utilise aussi des pointeurs 16 bits, sauf pour l'accès à certains 
périphériques de stockages qui nécessitent des adresses de 32 bits. Dans ce cas on utilise un entier double pour les représentés.
</p>
<h3>Le dictionnaire</h3>
<p> L'autre élément fondamental du Forth est ce qu'on appelle le dictionnaire.  Le dictionnaire Conserve le nom de tous les symboles utilisés par
le langage, les opérateurs arithmétique, logiques, relationels, les fonctions, les variables et les constantes. À chacun des ces symboles est associé
un pointeur qui indique l'action qui doit-être exécutée lorsque ce nom est invoqué dans un programme où sur la ligne de commande interactive. Par exemple
si on invoque le nom d'une constante sa valeur est empilée au sommet de la pile des arguments. Si on invoque le nom d'une variable l'adresse de celle-ci
est empilée au sommet de la pile des arguments. Si on invoque le nom d'un opérateur arithmétique comme <b>+</b> cette opération est exécutée en utilisant
les 2 valeurs au sommet de la pile des arguments.
</p>
<h3>Constantes et variables système</h3>
<p>
	La machine virtuelle ForthEx utilisent un certain nombre de constantes et variables qui sont accessible au programmeur nous les mentionnerons
	lors de leur utilisation.
</p>
<h2>La syntaxe Forth</h2>
<p> Je dirais que ce qui caractérise le plus le langage Forth est la simplicité de la syntaxe. Un programme Forth est simplement une liste de mots
séparés par un espace. L'interpréteur lit un mot et le cherche dans le dictionnaire, s'il le trouve il exécute immédiatement l'action qui est associé
à ce mot. Si le mot n'est pas dans le dictionnaire ce doit-être un entier (simple ou double) et dans ce cas l'interpréteur empile la valeur de cet entier.
L'interpréteur Forth est donc très simple: Lire le prochain mot, le chercher dans le dictionnaire, exécuter son action si trouvé. Sinon vérifier si c'est
un nombre et empiler ce nombre autrement arrêter et signaler une erreur.
</p>
<p>
	Lorsqu'on est en train de compiler une nouvelle définition dans le dictionnaire, la seule différence est que l'interpréteur compile l'adresse du code
	à exécuter au lieu de l'exécuter à moins qu'il s'agisse d'un mot <i>immédiat</i>. Les mots <i>immédiat</i> sont toujours exécutés immédiatement même
	lors d'une compilation. 
</p>
<h3>Les commentaires</h3>
<p> Il y a deux types de commentaires en Forth ceux introduit par le mot <b>(</b> et qui se termine par le délémiteur <b>)</b> et ceux qui sont 
    introduit par le mot <b>\</b> et qui se termine à la fin de la ligne. Notez que j'ai dit qu'il s'agissait de <b>mots Forth</b>. Ça signifit 
    qu'il faut qu'ils soient séparés par un espace de chaque côté.<br>
    <textarea id="code" style="height:100px;">
		\ ceci est un commentaire qui se termine à la fin de la ligne.
		\ceci génère une erreur, l'interpréteur va affiché: \ceci?
		( ceci est un commentaire qui se termine ici)
		(ceci génère une erreur, l'interpréteur va affiché: (ceci? 
    </textarea><br>
    Lorsque l'interpréteur ne trouve pas le mot dans le dictionnaire et que ce n'est pas un nombre il s'arrête en affichant le
    mot suivit d'un point d'interrogation.
</p>
<p>
	Il existe une forme de commentaire qui sert à décrire en abrégé l'interface d'un mot (fonction). Vous rencontrerai cett forme de commentaires
	en lisant la description de chaque mot du langage ForthEx. Voici un exemple:<br>
	<textarea id="code">
	: xy&gt;ucoord ( c1 c2 -- u )
		256 * + ; 
	</textarea><br>
	Le commentaire <b>( c1 c2 -- u )</b>  nous informe que la fonction <b>xy&gt;ucoord</b> accepte comme arguments 2 caractères (octets) et retourne
	un entier non signé. 
</p>
<p>
	Une autre forme de commentaire nous aide à nous rappeller ce qui se trouve sur la pile des arguments. Voici la définition du même avec
	ce type de commentaire.<br>
	<textarea id="code" style="height:150px;">
	: xy&gt;ucoord ( c1 c2 -- u )
		256 \ s: x y 256
		*    \ s: x n ( * a consommé y et 256 n est le produit.)
		+ ;  \ s: uccoord ( ucoord est la somme de x et n.)
	</textarea><br>
	L'argument <b>c1</b> représente une coordonnée <b>x</b>, l'argument <b>c2</b> représente une coordonnée <b>y</b> et l'entier non signé final
	est une version compressée du couple {x,y}  appellé  <b>ucoord</b>. <b>S:</b> représente la pile des arguments et ce qui suis son contenu.
	La valeur la plus à droite est au sommet de la pile.
</p>
<h3>Les indentifiants</h3>
<p>
	Puisqu'en Forth seul l'espace est utilisé comme séparateur de mot, un mot peut être formé avec n'importe quel caractère sauf l'espace.
	<br><textarea id="code" style="height:100px">
		&*/ \ ceci est un nom valide
		snake-len \ ça aussi il n'y a pas d'espace de
		\ chaque côté du '-' donc ce n'est pas un mot
		\ en lui-même.
	</textarea><br>
</p>
<h3>La notation préfixée.</h3>
<p> Autre particularité de la syntaxe Forth est que les arguments ( sauf exception ) sont énoncés avant la fonction. C'est ce qu'on appelle la
notation préfixée. exemple.
   <textarea id="code" style="height:100px;">
	   34 56 *  \ multipliation de 34 par 56
	   21 7 /  \ division de 21 par 7
	   12 7 2 - * \ en infixe serait écris: 12*(7-2)
   </textarea>
</p>
<h3>Débutons le codage</h3>
<p>
	À ce point çi nous disposons suffisamment d'information pour débuter l'écriture du code. Si nous avons manquer un point nous nous ajusterons en
	cours de route. Mais d'abord il faut répondre à quelques questions.
	<div><ul>
	<li>Quel sera la longueur initiale du serpent? J'ai opté pour 4.</li>
	<li>Est-ce que le serpent a une position et une direction initiale fixes, où laissons-nous ça au hasard? J'ai décidé qu'il démarrait au
	centre de l'écran et se dirigeait vers l'est.</li>
	</ul></div>
</p>
<p>
	Commençons donc à créer notre programme snake.<br>
	Définissons quelques constantes. Les constantes sont créées avec le mot <b>CONSTANT</b>. On entre la valeur de la constante
	ensuite le mot <b>constant</b> suivit de sont nom. Une fois une constante créée il suffit d'invoquer son nom pur que sa valeur soit déposée au
	sommet de la pile des arguments.<br>
	<textarea id="code" style="height:220px;">
	128 constant max-len \ longueur maximale du serpent.
	\ directions des deplacements
	0 constant east
	1 constant south
	2 constant west
	3 constant north
	62 constant play-width \ largeur aire de jeu
	22 constant play-height \ hauteur aire de jeu
	2 constant x-offset \ décalage coordonnee X dans l'affichage
	2 constant y-offset \ décalage coordonnee Y dans l'affichage
	143 constant vk_left \ code touche fleche gauche
	144 constant vk_right \ code touche fleche droite	
	</textarea><br>
	Sans surprise les variables sont créées à l'aide du  mot <b>VARIABLE</b>. Lorsqu'une variable est invoquée c'est sont adresse qui est déposée
	au sommet de la pile. Ce qui permet de lire sa valeur avec le mot <b>@</b> ou bien de modifier cette valeur avec le mot <b>!</b>.<br>
	<textarea id="code" style="height:180px;">
	\ création des variables, elles sont inialisée à 0 lors de
	\ leur création.
	variable score \ pointage
	variable head \ direction serpent
	variable snake-len \ longueur serpent
	variable food \ localisation pastille nourriture
	variable tail \ localisation queue serpent
	</textarea>
</p>
<p>
	Il nous reste encore 2 variables à créer mais ces variables sont de type tableau (quoique je préfère le mot vecteur). Avant de créer ces 2 variables vecteurs
	je vais définir un mot particulier appellé <b>VECTOR</b>. De la même manière que le mot <b>VARIABLE</b> nous a permit de créer des objets 
	de type <i>variable</i>, le mot <b>VECTOR</b> va nous permettre de créer des objets de type <i>vecteur</i>.
	<br>
	<textarea id="code" style="height:120px;">
		\ VECTOR va nous permettre de créer des 
		\ variables de type vecteur.
		\  cccc représente le prochain mot dans le texte d'entrée
		\ n est le nombre d'éléments du vecteur.
		: VECTOR ( cccc s: n -- )
		  CREATE CELLS ALLOT DOES&gt; SWAP CELLS + ;
    </textarea>
</p> 
<p>
	Dans ce tutoriel je vais appeller les mots qui servent à créer d'autres mots dans le dictionnaire <b>mots compilants</b>. <b>CONSTANT</b> <b>VARIABLE</b>,
	<b>:</b> et <b>CREATE</b> sont des <b>mots compilants</b>. Et maintenant que nous l'avons créé le mot <b>VECTOR</b> est aussi un <b>mot compilant</b>.
</p>
<p>
	Le premier mot que nous avons utiliser pour définir <b>VECTOR</b> est le mot <b>:</b> Ce mot cré une nouvelle entrée dans le dictionnaire qui porte
	le nom qui le suis dans le texte d'entrée. En l'occurence ici il s'agit du mot <B>VECTOR</B>. Il existe une variable système qui s'appelle <b>STATE</b>.
	Cette variable détermine l'action de l'interpréteur. Lorsque cette variable est à <b>0</b> l'interpréteur exécute immédiatement chaque mot qu'il lit dans le
	texte d'entrée. Mais lorsque <b>STATE</b> a la valeur <b>-1</b>, l'interpréteur compile dans le dictionnaire l'adresse du code d'action au lieu de
	l'exécuter. Le mot <b>:</b> après avoir créer une entrée dans le dictionnaire pour <b>VECTOR</b> change la valeur de <b>STATE</b> à <b>-1</b>. Donc tous
	les mots qui suivent le mot <b>VECTOR</b> seront compilés dans le dictionnaire à la suite du mot <b>VECTOR</b>. Il y a une exception. Les mots dits <i>
	immédiat</i> sont quand même exécutés lorsque STATE est à -1. dans la définition de <b>VECTOR</b> on utilise 2 mots immédiats <b>DOES&gt;</b>
	et <b>;</b>. Le mot <b>;</b> est utiliser pour terminer une définition, il sert simplement à remettre à <b>0</b> la valeur de <b>STATE</b>.
</p>
<p> Le mot <b>DOES&gt;</b> est plus complexe. Il termine la définition du mot <b>VECTOR</b> et compile une action qui va être exécutée par les mots créés avec
<b>VECTOR</b>. Autrement dit les mots créés par <b>VECTOR</b>, lorsqu'ils seront invoqués, vont exécuter le code:
<br><textarea id="code" > SWAP CELLS + </textarea> <br>
</p>
<p>
	Donc lorsque l'interpréteur à terminé la lecture du code ci-haut on a une nouvelle entrée dans le dictionnaire, <b>VECTOR</b> et on va s'en servir
	pour créer des variables de type <i>vecteur</i>. Voici ce qui se passe lorsqu'on invoque le mot <b>VECTOR</b>. Regardons la partie de sa 
	définition qui précède <b>DOES&gt;</b>.<br>
	<textarea id="code" >CREATE CELLS ALLOT</textarea><br>
	Seulement 3 mots.
	<ul>
		<li><b>CREATE</b>, Lit le prochain mot dans le texte d'entré et cré une nouvelle entrée dans le dictionnaire avec ce nom. Lorsqu'un mot
		qui a été créé par <b>CREATE</b> est invoqué son action est de déposé au sommet de la pile l'adresse du premier octet de donnée, ce
		qu'on appelle <b>PFA</b> pour <i>Parameter Field Address</i>.</li>
		<li><b>CELLS</b>, Multiplie la valeur qui est au sommet de la pile par le nombre d'octets d'une cellule. En ForthEx l'on l'a dit
		les cellules sont de 16 bits donc 2 octets. Donc la valeur au sommet de la pile est multipliée par 2.</li>
		<li><b>ALLOT</b>, Consomme la valeur au sommet de la pile des arguments et se sert de cette valeur pour réserver l'espace nécessaire 
		dans l'espace de données pour stocker le nombre d'octets indiqué par cette valeur.</li>
	</ul><br>
	<textarea id="code" style="height:200px;">
	\ creation des variables vecteur.		
	\ tableau de 4 car. representant la tete du serpent.
	4 vector c-head
	\ le corps du serpent.
	max-len vector snake
	
	\ initialiation de c-head
	'&lt;' east c-head !
	'W' south c-head !
	'&gt;' west c-head !
	'M' north c-head !
	</textarea><br>
	Prenons l'exemple de <b>C-HEAD</b>. On empile la valeur <b>4</b> qui sera consommé par <b>VECTOR</b> qui est invoqué à la suite de son
	argument suivit du nom de la <i>variable vecteur</i>, ici <b>C-HEAD</b>. Une fois que l'interpréteur a lu cette phrase il y a donc un 
	nouveau mot dans le dictionnaire appellé <b>C-HEAD</b>. l'initialisation de <b>C-HEAD</b> nous montre comment utiliser un vecteur.
	Les vecteurs consomme 1 argument et en retourne 1. Un <b>vecteur</b> consomme un entier non signé représenté par <b>u</b> et retourne 
	une adresse alignée sur une cellule représenté par <b>a-addr</b>.  La valeur de <b>u</b> indique quel élément du vecteur nous voulons 
	atteindre. Le permier élément d'un vecteur porte l'indice <b>0</b>, le deuxième l'indice <b>1</b>, etc. Prenons en exemple la phrase suivante:
	<br><textarea id="code">
	'&lt;' east c-head !	
	</textarea><br>
	Cette phrase comprend 4 mots, voyons ce qui se trouve sur la pile des arguments après l'exécution de chacun d'eux.<br>
	<table border="single">
	<tr><th>mot</th><th>description</th><th>État de la pile</th></tr>	
	<tr><td>'&lt;'</td><td>Il s'agit d'un entier de type caractère dont la valeur ASCII est 60.</td><td>60</td></tr>
	<tr><td>east</td><td>Il s'agit d'une constante ça valeur est empilée.</td><td>0<br>60<br</td></tr>
	<tr><td>c-head</td><td>Il s'agit d'un vecteur. Il consomme la valeur au sommet de la pile et le<br>
	remplace par l'adresse de cet élément.</td>
	<td>a-addr<br>60</td></tr>
	<tr><td>!</td><td>Ce mot consomme 2 valeurs sur la pile. Le premier est une adresse et<br>
	le deuxième élément est la valeur à déposer à cette adresse.</td><td><i>pile vide</i><br>maintenant c-head[0]=60</td></tr>
	</table>
</p>
<p> 
	Comment est calculé l'adresse de l'élément du vecteur? C'est justement la partie de la définition de <b>VECTOR</b> qui suis <b>DOES&gt;</b>
	qui fait ce travail. Lorsque le mot <b>C-HEAD</b> est invoqué l'adresse de son champ de données est déposé au sommet de la pile ensuite le
	code suivant est exécuté.<br>
	<table border="single">
	<tr><th>mot</th><th>description</th><th>État de la pile</th></tr>	
	<tr><td></td><td>Avant l'invocation de c-head on sur la pile</td><td>0<br>60</td></tr>
	<tr><td>c-head</td><td>Lorsque c-head est invoqué mais avant que le code DOES&gt;<br>
	ne soit exécuté on sur la pile.</td><td>pfa<br>0<br>60</td></tr>
	<tr><td>swap</td><td>Commute les 2 éléments au sommet de la pile.</td><td>0<br>pfa<br>60</td></tr>
	<tr><td>cells</td><td>Multiplie l'indice au sommet de la pile par 2.</td><td>2*0<br>pfa<br>60</td></tr>
	<tr><td>+</td><td>Additionne les 2 valeurs au sommet de la pile. a-addr=0+pfa</td><td>a-addr<br>60</td></tr>
	</table><br>
	Là on voulait accéder l'élément 0 du vecteur donc l'adresse n'a pas changée mais pour les autre éléments l'adresse est incrémentée de
	<b>2*i</b> où <b>i</b> est l'indice qu'on veut accéder. 
</p>
<p>
	Notez ici combien il est important lorsqu'on programme en Forth de connaître se qu'il y a sur la pile des arguments ou même des retours si on
	utilise cette dernière pour conserver des valeurs temporairement. On peut s'aider à l'aide de commentaires qui indique les valeurs sur
	la pile des arguments par une liste précédé de <b>S:</b> et <b>R:</b> pour la pile des retours. Voici un exemple de commentaire.
	<br><textarea id="code" style="height:100px;">
	4 3 \ après avoir empilé 4 et 3 on a S: 4 3
	>r  \ après avoir transféré T sur R on a S: 4  R: 3
	drop r> \ après avoir jeté T et transféré R sur S on S: 3 R:
	</textarea><br>
	Pour comprendre cet exemple il faut savoir qu'on nomme le sommet de la pile des arguments <b>T</b> et que le mot <b>&gt;R</b> 
	transfert le sommet de la pile des arguments vers la pile des retours et que
	le mot <b>R&gt;</b> fait exactement le contraire. Tandis que le mot <b>DROP</b> jette la valeur au sommet de la pile des arguments.
</p>
<h3>Premiers mots du jeu</h3>
<p>
	On va maintenant définir quelques mots qui seront utilisés dans les graphismes du jeu.<br>
	<textarea id="code" style="height:100px;">
	\ fonctions graphiques
	\ conversion entier non signe vers couple {x,y}
	: ucoord>xy ( u -- x y )
	   256 /mod ;
	</textarea><br>
	Chaque définition d'une fonction commence par le mot <b>:</b> et se termine par le mot <b>;</b>. Le mot <b>ucoord&gt;xy</b> convertie un
	entier non signé en 2 octets représentant un couple de coordonnées {x,y}. L'opération est simple puisqu'il s'agit simplement de diviser
	l'entier par <b>256</b> et de conserver le quotient et le reste. <b>y</b> est le quotient et <b>x</b> le reste. <b>/mod</b> divise un 
	entier par un autre en conserve le quotient et le reste. Le quotient est au sommet de la pile.<br>
	<textarea id="code" style="height:100px;">
	\ conversion couple {x,y} vers ucoord
	: xy>ucoord ( x y -- u )
	   256 * + ;
	</textarea><br>
	Le mot <b>xy&gt;ucoord</b> est l'inverse du mot précédent. Il convertie un couple de coordonnées {x,y} en un entier non signé que j'appelle
	tout au long de ce tutoriel une <i>ucoord</i>. Cette conversion est tout aussi simple que la première puisqu'il s'agit simplement de
	multiplier <b>y</b> par 256 et ensuite d'additionner <b>x</b> au produit. Pour que ça fonctionne <b>x</b> et <b>y</b> doivent-être dans le
	domaine {0..255}.<br>
	<textarea id="code" style="height:100px;">
	\ dessine un pixel  c caractere {x,y} coord.
	: draw-pixel ( c x y -- )
	   y-offset + swap x-offset + swap at-xy emit ;
	</textarea><br>
	Le mot <b>draw-pixel</b> en fait affiche un caractère <b>c</b> à la position de l'écran déterminé par le couple de coordonnées <b>{x,y}</b>.
	On doit d'abord ajuster les coordonnées à celle de l'écran du moniteur. Selon les coordonnées de l'écran du moniteur le coin supérieur gauche
	de l'aire de jeu est à la position {2,2} donc on ajoute <b>y-offset</b> dont la valeur est 2 et x-offset dont la valeur est aussi 2 à chacune
	des coordonnées. Le mot <b>swap</b> est utilisé pour commuter la position des 2 éléments qui sont au sommet de la pile. Pour travailler sur
	<b>x</b> on le met au sommet avec le premier <b>swap</b> et une fois <b>x</b> ajusté on remet les coordonnées dans le bon ordre avec le second
	<b>swap</b>. Le mot <b>at-xy</b> sert simplement à déplacer le curseur texte à la position désignée par {x,y}. Le mot <b>emit</b> lui sert à
	afficher le caractère <b>c</b> à cette position de l'écran.<br> 
	<textarea id="code" style="height:100px;">
	\ dessine une pastille u=ucoord
	: draw-ring ( u -- )
	   true b/w
	   'O' swap ucoord>xy draw-pixel false b/w ;
	</textarea><br>
	le mot <b>draw-ring</b> sert à dessiner une pastille en inverse vidéo. Ces pastilles représente à la fois la nourriture et les anneaux qui 
	construisent le corps du serpent. Le mot <b>b/w</b> consomme un argument booléen et met le mode vidéo en noir sur fond blanc lorsque cette valeur
	est vrai on en vidéo normale si elle est fausse. <b>b/w</b> signifit <i>Black on White</i>. Puisqu'on dessine les anneaux en inverse vidéo
	on fait donc <b>true b/w</b>. <b>draw-ring</b> consomme un argument <b>u</b> qui est l'<i>ucoord</i> de la position.  On convertie cette valeur
	en couple<b>{x,y}</b> avant d'appeller <b>draw-pixel.</b> Finalement on retourne au mode vidéo normal avec <b>false b/w</b>.
	<br>
	<textarea id="code" style="height:100px;">
	\ dessine les bandes de l'arene
	: draw-walls ( -- )
	   cls 1 whiteln 24 whiteln
	   24 2 do 1 i at-xy space 64 i at-xy space loop false b/w ;

	</textarea><br>
 Le mot <b>draw-walls</b> dessine la bordure qui délimite l'aire du jeu. le mot <b>cls</b> vide l'écran de la console. <b>1 whiteln</b> dessine 1
ligne blanche à la position y qui lui est fournie. Ici 2 lignes blanche sont dessinées en haut et en bas de l'écran. Pour dessiner les lignes verticales
à droite et à gauche de l'écran on utilise une boucle avec compteur <b>DO ... LOOP</b>.  Entre le mot <b>do</b> et le mot <b>loop</b> se sont les 
instructions qui s'exécutent en bloucle.Le mot <b>DO</b> consomme 2 arguments, <b>24</b> est la limite du compteur et  <b>2</b> est la valeur initiale 
du compteur. On a déjà vu le mot <b>at-xy</b> qui consomme 2 arguments, soit les coordonnées colonne et ligne où doit-être positionner le curseur texte. 
le mot <b>i</b> sert à empiler la valeur du compteur de boucle. Les instructions de la boucle commence donc par empiler la valeur <b>i</b> ensuite la 
la valeur du compteur de boucle, dont la valeur est 2 à la première itération. On positionne le curseur et on affiche un caractère espace en invoquant le
mot <b>space</b>. Comme on est en inverse vidéo cet espace apparaît comme un carré blanc. On recommence l'opération à la colonne <b>64</b> et on arrive à 
<b>loop</b> qui incrémente le compteur pour ensuite le comparé à la limite. Si cette limite est atteinte l'exécution continue après le <b>loop</b> sinon
on retourne après le <b>do</b>. Donc ici puisque <b>do</b> a été initialisé avec une limite de <b>24</b> le traçage des lignes verticales se termine à la
ligne 23.<br>

	<textarea id="code" style="height:100px;">
	\ dessine le serpent
	: draw-snake ( -- )
	   head @ c-head @ 0 snake @ ucoord>xy draw-pixel
	   snake-len @ 1 do i snake @ draw-ring loop ;

	</textarea><br>
Le mot <b>draw-snake</b> sert à dessiner le serpent. On commence par dessiner la tête. Comme on l'a dit le caractère utilisé pour la tête dépend de la
direction du mouvement du serpent. Cette direction est indiquée par la valeur de la variable <b>HEAD</b>. On lit donc cette valeur avec la phrase
<b>head @</b> et cette valeur sert d'indice pour aller chercher le bon caractère dans le vecteur <b>c-head</b> par la phrase <b>c-head @</b>. Ensuite on
obtient la position de la tête du serpent avec la phrase <b>0 snake @</b> et on dessine la tête avec la phrase <b>ucoord&gt;xy draw-pixel.</b> Pour dessiner
le corps du serpent on utilise encore une boucle <b>do...loop</b>. Cette boucle est initialisée avec la longueur du serpent qu'on obtient avec la phrase
<b>snake-len @</b> et l'indice de départ est <b>1</b> puisqu'on a déjà dessiner la tête. la phrase <b>i snake @</b> nous donne la coordonnée de l'ième 
élément du serpent et <b>draw-ring</b> dessine l'anneau. Et bien sur <b>loop</b> incrémente le compteur et nous renvoie au début de la boucle tant qu'on
a pas atteint la limite.
<br>
	<textarea id="code" style="height:100px;">
	\ dessine pastille nourriture
	: draw-food ( -- )
	   true b/w 'O' food @ ucoord>xy
	   draw-pixel false b/w ;
	</textarea><br>
<b>draw-food</b> sert à dessiner la pastille de nourriture en inverse vidéo. La position de la pastille est conservée dans la variable <b>food.</b>
 Donc après être passé en mode vidéo inverse par la phrase <b>true b/w</b> on obtient la position par la phrase <b>food @</b>, on convertit l'entier
 en couple x,y avec <b>ucoord&gt;xy</b> avant d'appeller <b>draw-pixel</b>. Pour conclure on repasse en vidéo normal avec <b>false b/w.</b>
<br>
	<textarea id="code" style="height:100px;">
	\ déplace le serpent dans la direction
	\ indiquée par la variable HEAD.
	: move-snake ( -- )
	   0 snake @ dup ucoord>xy
	   head @ case
		   east of swap 1+ swap endof
		   south of 1+ endof
		   west of swap 1- 255 and swap endof
		   north of 1- endof
		   endcase xy>ucoord
	   0 snake !
	   snake-len @ 1 do i snake dup >r @ swap r> !
	   loop dup tail !
	   bl swap ucoord>xy draw-pixel draw-snake ;

	</textarea><br>
Le mot <b>move-snake</b>, qui sert à déplacer le serpent, est plus complexe que les précédent. Je vais donc commencer par expliquer comment on déplace le
serpent avant d'examiner le code qui effectue cette action.
<ol>
	<li>La variable <b>head</b> nous indique dans qu'elle direction on doit déplacer le serpent. Selon la valeur de <b>head</b> on doit:
	<table border="single">
		<tr><th>head</th><th>modification</th></tr>
		<tr><td>est</td><td>x=x+1</td></tr>
		<tr><td>sud</td><td>y=y+1</td></tr>
		<tr><td>ouest</td><td>x=(x-1)&255</td></tr>
		<tr><td>nord</td><td>y=y-1</td></tr>
	</table>
	</li>
	<li>Le corps du serpent suis la tête çe qui signifit qu'une fois que la tête a été déplacée le premier anneau va à la position précédente
	de la tête. Le deuxième anneau à la position précédente du premier anneau, ainsi de suite jusqu'à la queue du serpent.</li>
	<li>Il s'agit donc de déplacer la tête en premier pour ensuite utiliser une boucle <b>do...loop</b> pour déplacer le reste du serpent.</li>
</ol>
	On commence donc par lire la valeur <i>ucoord</i> de la tête du serpent avec la phrase <b>0 snake @</b>. <b>dup</b>fait une copie de cette valeur
	car nous aurons besoin de cette valeur pour l'affecter au premier anneau du serpent. On transforme l'entier en couple <b>x,y</b> avec <b>ucoord&gt;xy</b>.
<h4>CASE</h4>
<p> Voici comment fonctione le <b>CASE</b> en Forth. Le <b>CASE</b> sert à sélectionner un choix multiple en comparant la valeur au sommet de la pile
avec différentes valeurs de contrôles. Ici la valeur au sommet de la pile est la direction obtenue par <b>head @</b>. Après le <b>case</b> suis la liste
des valeurs de contrôle. Dans ce cas ci, il s'agit des constantes <b>east, south, west et north</b>. Le mot <b>of</b> suis chaque valeur de contrôle et
est lui-même suivit du code à exécuter si la valeur de contrôle est égale à la valeur au sommet de la pile. <b>endof</b> indique la fin du code pour
cette condition. Il y a autant de <b>x of .... endof</b> qu'il y a de valeurs à contrôler. Le mot <b>endcase</b> termine le <b>case</b> en retirant
du sommet de la pile la valeur utilisée par <b>case</b>. Si aucune condition n'est rencontrée on peut insérer entre le dernier <b>endof</b> et 
<b>endcase</b> du code qui sera exécuté par défaut. <b>Attention</b>, si le code par défaut laisse une valeur sur la pile il doit faire un <b>swap</b>
pour ramené la valeur utilisée par <b>case</b> au sommet pour que celle-ci soit jetée par <b>endcase</b>.
</p>
<p> Maintenant que les coordonnées de la tête ont étées modifiées à l'intérieur du <b>case</b> on reconvertie le couple <b>x,y</b> en <i>ucoord</i>
avant de sauvegarder cette nouvelle valeur dans l'élément 0 du vecteur <b>snake</b> par la prhase <b>xy&gt;ucoord 0 snake !</b>.
</p>
<p>A ce point ci il nous reste au sommet de la pile l'ancienne <i>ucoord</i> de la tête. On commence une boucle pour déplacer le reste du serpent.
<b>snake-len @ 1 do</b>. Le code à l'intérieur du <b>do...loop</b> est en fait simple à comprendre. Pour chaque élément <b>i</b> du vecteur snake,
on commence par lire la valeur actuelle, on commute les 2 éléments au sommet de la pile et on sauvegarde la valeur qui est maintenant au sommet dans
cet ième élément. <b>dup &gt;r</b> sert simplement à conserver une copie de l'adresse du ième élément sur la pile des retours pour ensuite récupérer cette
adresse avec <b>r&gt;</b> lorsque viens le temps d'enregistrer la nouvelle valeur <i>ucoord</i> de cet élément. Gardez en tête qu'au début de chaque boucle
la valeur qui est au sommet de la pile des arguments est la position avant déplacement de l'élément précédent du serpent. Action à l'intérieur de la boucle:
<br><b>i snake dup &gt;r @ swap r&gt; !</b><br><table border="single">
<tr><th>action</th><th>S:</th><th>R:</th><th>commentaire</th></tr>
<tr><td></td><td>ucoord</td><td></td><td>juste avant de débuter le do...loop<br>on a sur la pile<br>l'ancienne position de la tête.</td></tr>	
<tr><td>i</td><td>compteur-boucle<br>ucoord</td><td></td><td>Le compteur de boucle débute à 1</td></tr>
<tr><td>snake</td><td>a-addr(i)<br>ucoord</td><td></td><td>Maintenant au sommet de la pile<br>on a l'adresse du ième élément du vecteur snake.</td></tr>
<tr><td>dup</td><td>a-addr(i)<br>a-addr(i)<br>ucoord</td><td></td><td>On a créer une copie de l'adresse.</td></tr>
<tr><td>&gt;r</td><td>a-addr(i)<br>ucoord</td><td>a-addr(i)</td><td>On envoie la copie sur la pile des retours.</td></tr>
<tr><td>@</td><td>ucoord-i<br>ucoord</td><td>a-addr(i)</td><td>Maintenant on a au sommet de S: <i>ucoord</i> du ième élément.</td></tr>
<tr><td>swap</td><td>ucoord<br>ucoord-i</td><td>a-addr(i)</td><td>On a commuter les 2 éléments au sommet de S:</td></tr>
<tr><td>r&gt;</td><td>a-addr(i)<br>ucoord<br>ucoord-i</td><td></td><td>On a ramené l'adresse du ième élément sur S:</td></tr>
<tr><td>!</td><td>ucoord-i</td><td></td><td>On a sauvegarder la valeur de l'élément (i-1) dans l'élément (i)<br>
et conserver l'ancienne valeur de l'élément (i) au sommet de S:</td></tr>
</table><br>
Lorsqu'on quitte la boucle <b>do...loop</b> il reste au sommet de la pile <i>l'ucoord</i> de la queue du serpent avant déplacement. On doit faire 2 
choses avec cette valeur. Premièrement on cré une copie et on la conserve dans la variable <b>tail</b>, <b>dup tail !</b>. Ensuite on va effacer
L'anneau qui se trouve à cette position puisque le serpent s'est déplacé il n'y a plus rien à cette coordonnée. <b>bl swap ucoord&gt;xy draw-pixel</b>.
Finalement on appelle <b>draw-snake</b> pour redesssiner le serpent au complet à sa nouvelle position.
</p>
<p>Pourquoi conserve-t'on l'ancienne position du dernier à anneau du serpent dans tail?  Parce qu'au moment où on déplace le serpent on ne sais pas
encore si le serpent a avalé la pastille de nourriture. Lorsqu'on va faire cette vérification et dans l'éventualité ou on doit rallonger le serpent
on va dessiner le nouvel anneau à cette position.
</p><p>
	<textarea id="code" style="height:100px;">
	\ affiche le status
	: status ( -- )
	   true b/w 1 1 at-xy s" SCORE:" type score @ .
	   16 1 at-xy s" LENGTH:" type snake-len @ . false b/w ;

	</textarea><br>
<br>
<p> Le mot <b>status</b> sert à afficher l'état du jeu, soit le pointage et la longueur du serpent. Cette affichage est présenté sur la première ligne
de l'écran en inverse vidéo, le mot commence donc par la phrase <b>true b/w</b> puis la phrase <b>1 1 at-xy</b> déplace le curseur dans le coin supérieur
gauche de l'écran.  La phrase <b>s" SCORE:" type</b> affiche le texte entre guillemets. On obtient le pointage par la lecture de la variable <b>score</b>
et on imprime cette valeur à la position courante du curseur texte avec le mot <b>.</b> En Forth le mot <b>.</b> <i>(point)</i> sert à imprimer l'entier 
qui se trouve au sommet de la pile. Ensuite on déplace le curseur texte à la colonne 16, ligne 1 avec la phrase <b>16 1 at-xy</b> et imprime le texte 
<i>LENGHT:</i> avec la phrase <b>s" LENGTH:" type</b>. Finalement on affiche la longueur du serpent avec la phrase <b>snake-len @ .</b>. Avant de 
quitter on repasse en mode vidéo normal <b>false b/w</b>.
</p>
<h3>La logique du jeu</h3>
<P>On va commencer à examiner les mots qui construisent la logique du jeu.
	<br><textarea id="code" style="height:300px;">
	\ Lors de la creation d'une patille il faut valider
	\ qu'elle ne superpose pas au serpent.
	: valid-food? ( u -- f )
	   true swap snake-len @ 0 do
		   i snake @ over = if swap drop false swap leave then
		   loop drop ;

	\ creation d'une pastille de nourriture
	: new-food ( -- )
	   0 \ valeur à jeter
	   begin 
		   drop
	       rand abs play-width mod \ x
		   rand abs play-height mod \ y
		   xy>ucoord dup valid-food? until food ! ;

	\ verifie si le serpent se mord.
	: snake-bit? ( -- f )
	   false 0 snake @  snake-len @ 1 do
		   i snake @ over = if swap drop true swap leave then
		   loop drop ;

	\ verification collision avec mur
	: wall-bang? ( -- f )
	   0 snake @ ucoord>xy  play-height 1- u>
	   swap  play-width 1- u> or ;

	\ verification collision
	: collision? ( -- f )
	   snake-bit? wall-bang? or ;

	\ les pastilles dans un coins valent 4  points
	: in-corner? ( u1 -- f )
	   ucoord>xy dup 0= swap play-height 1- = or
	   swap dup 0= swap play-width 1- = or and ;

	\ les pastilles qui sont le long du mur valent 2 points
	: on-wall? ( u1 -- f )
	   ucoord>xy dup 0= swap play-height 1- = or
	   swap dup 0= swap play-width 1- = or or ;

	\ ajuste SCORE
	: score+ ( -- )
	   food @ dup in-corner? if drop 4 else
	   on-wall? if 2 else 1 then
	   then score +! 0 food ! ;

	\ rallonge le serpent
	: snake+ ( -- )
	   snake-len dup >r @ dup 1+ r> ! tail @  swap snake ! ;

	 \ initialisation du serpent
	: snake-init ( -- )
	   east head !
	   play-width 2/ play-height 2/ snake-len @ 0 do
	   2dup xy>ucoord i snake ! swap 1- swap loop 2drop ;

	\ lecture clavier touche 'q' quitte le jeu.
	: game-exit? ( -- f )
	   ekey? if ekey case
	   ar_left of head @ 1- 3 and head ! false endof
	   ar_right of head @ 1+ 3 and head ! false endof
	   'q' of true endof
	   'Q' of true endof
	   >r false r>
	   endcase else false then ;

	\ pastille mangee?
	: eaten? ( -- f )
	   0 snake @ food @ = ;

	\ boucle du jeu
	: game-loop ( -- )
	  begin
	  speed ms
	  status food @ 0= if new-food then draw-food
	  game-exit? ?dup 0= if
	  move-snake eaten? if score+  snake+ false else
	  collision? then then until ;

	\ initialisation du jeu
	: game-init ( -- )
	   srand 4 snake-len ! 0 score !
	   snake-init draw-walls ;

	\ partie terminee
	: game-over ( -- )
	   1 24 at-xy s" game over <Q> leave" type key ;

	\ lance le jeux.
	: snake-run ( -- )
	   begin game-init game-loop game-over 'q' = until cls ;

	</textarea><br>
	Le mot <b>valid-food?</b> vérifie la position de la pastille par rapport au corpd du serpent.
	Lorsque la pastille de nourriture a été gobée par le serpent une nouvelle pastille doit-être créé. La position de cette pastille est déterminée au 
	au hasard donc on doit s'assurer qu'elle n'est pas sur le serpent. <b>valid-food?</b> compare donc la <i>ucoord</i> de la pastille nouvellement générée
	avec la position de chacun des anneaux du serpent. S'il y a coîncidence <b>valid-food?</b> retourne la valeur <b>FALSE</b>. <b>valid-food?</b> consomme
	donc en argument la <i>ucoord</i> de la pastille et retourne une valeur booléene <i>f</i>. On commence par déposer sur la pile la constante <b>TRUE</b>
	en la glissant en 2ième position avec <b>swap</b>. Ensuite on initialise une boucle ave compteur <b>snake-len @ 0 do</b>. <b>i snake @ over =</b> effectue
	la comparaison entre l'argument <i>u</i> et <i>l'ucoord</i> de l'ième anneau du serpent. C'est la première fois qu'on rencontre le mot <b>over</b> dans
	ce tutoriel. <b>over</b> fait une copie du 2ième élément de la pile et le dépose au sommet donc après l'exécution de <b>over</b> on a sur la pile des
	arguments:<br>
	<table border="single">
		<tr><th>S:</th></tr>
		<tr><td>u</td></tr>
		<tr><td>ucoord(i)</td></tr>
		<tr><td>u</td></tr>
		<tr><td>TRUE</td></tr>
	</table><br>
	Le mot <b>=</b> effectue une comparaison entre les 2 éléments au sommet de la pile et retourne <b>TRUE</b> s'il sont égaux. donc après l'exébution de
	<b>=</b> on a sur la pile:<br>
	<table border="single">
		<tr><th>S:</th></tr>
		<tr><td>f</td></tr>
		<tr><td>u</td></tr>
		<tr><td>TRUE</td></tr>
	</table><br>
	Le mot <b>if</b> considère la valeur au sommet de la pile et si cette valeur est vrai, (toute valeur différente de 0 est considérée comme vrai)
	les instructions situées entre le <b>if</b> et le <b>then</b> sont exécutées. l'indicateur booléen <i>f</i> est consommé par le <b>if</b>. Supposons
	que <i>f</i> est <b>VRAI</b>, alors la phrase suivante est exécutée: <b>swap drop false swap leave</b>:<br>
	<table border="single">
		<tr><th>mot<br>exécuté</th><th>S:</th></tr>
		<tr><td>swap</td><td>TRUE<br>u</td></tr>
		<tr><td>drop</td><td>u</td></tr>
		<tr><td>false</td><td>FALSE<br>u</td></tr>
		<tr><td>swap</td><td>u<br>FALSE</td></tr>
		<tr><td>leave</td><td>u<br>FALSE</td></tr>
	</table><br>
	Le mot <b>leave</b> sert à quitter prématurément une boucle <b>do ... loop</b> en faisant un saut juste après le <b>loop</b>. S'il y a superposition entre
	<i>u</i> et un <i>ucoord(i)</i> il n'est pas nécessaire de continuer. On remplace donc le <b>TRUE</b> qu'on avait mis en 2ième position sur la pile par
	un <b>FALSE</b> et on quitte. A la sortie de la boucle on jette la valeur <i>u</i> pour ne conserver que l'indicateur booléen.
</P>
<p>
	Le mot <b>new-food</b> introduit une nouvelle structure de contrôle, le <b>begin ... until</b>. Cette boucle se répète tant que la valeur laissée au 
	sommet de la pile par la liste d'instructions entre le <b>begin</b> et le <b>until</b> est <b>0</b>. On génère au hasard avec la fonction <b>rand</b> une
	valeur <i>x</i> et ensuite une valeur <i>y</i>. La phrase <b>rand abs play-width mod</b> est conçue pour limitée la valeur générée entre 0 et 
	<i>play-width-1</i>. <b>rand</b> génère un entier quelconque entre <b>-32768</b> et <b>32767</b>, <b>abs</b> retourne la valeur absolue de cet entier. 
	<b>play-width</b> empile la valeur <i>62</i> et <b>mod</b> retourne le reste de la division  de l'entier aléatoire par 62. La même opération est 
	répétée pour générer la coordonnée <i>y</i>. <b>xy>ucoord</b> convertit le couple {x,y} en <i>ucoord</i>, crée une copie avec <b>dup</b>
	et appel <b>valid-food?</b> pour faire la vérification dont on a parlé au paragraphe précédent. Si <b>valid-food?</b> retourne <b>TRUE</b> on quitte
	la boucle <b>begin ... until</b> et on sauvegarde <i>u</i> dans <b>food</b>. Par contre si <b>valid-food?</b> retourne <b>FALSE</b> la boucle se
	répète mais avant de générer une nouvelle valeur de 'u' on doit jeter celle qui n'est pas bonne, c'est pourquoi la boucle commence avec un 
	<b>drop</b> et qu'avant de commencer la boucle on avait mit sur la pile un <b>0</b> inutile.
</p> 
<p> On doit vérifier les collisions. Il y a 2 types de collisions, le serpend avec un mur et le serpent avec lui-même.
</p>
<p> Le mot <b>snake-bit?</b> Sert à vérifier que le serpent n'est pas entré en collision avec lui-même. Il s'agit simplement de comparer <i>l'ucoord</i> de la
tête du serpent avec chacun des anneaux du serpent. S'il y a égalité entre <i>ucoord(0)</i> et <i>ucoord(i)</i> c'est que le serpent se mord lui-même. Encore une 
fois on utilise une boucle avec compteur <b>do ... loop</b>. Mais avant d'entrée dans cette boucle on fait 2 choses. Premièrement on empile la constante
 <b>FALSE</b> et ensuite la phrase <b>0 snake @</b> empile <i>l'ucoord(0)</i>. Lorsqu'on entre dans la boucle on a donc 2 valeurs au sommet de la pile des
 arguments:<br>
 <table>
	<tr><th>S:</th></tr>
	<tr><td>ucoord(0)</td></tr>
	<tr><td>FALSE</td></tr> 
 </table><br>
 L'intérieur de la boucle est très similaire à ce qui se passe dans <b>valid-food?</b>. <b>i snake @ over = if swap drop true swap leave then</b>. Pour chaque
 élément <i>i</i> on compare <i>ucoord(0)</i> et <i>ucoord(i)</i> pour l'égalité et en cas d'égalité en remplace la constante <b>FALSE</b> en deuxième position
 de la pile par la constante <b>TRUE</b> et on quitte la boucle avec <b>LEAVE</b>. A la sortie de la boucle on jette la valeur <i>ucoord(0)</i> qui restait
 sur la pile pour ne conserver que l'indiccateur booléen <i>vrai/faux</i>.
</p>
<p>
 Le mot <b>wall-bang?</b> vérifie l'autre type de collision, i.e. serpent et mur. Cette détection ne requiert aucune boucle. Il suffit simplement de s'assurer
 que les coordonnées <b>x</b> et <b>y</b> de la tête du serpent sont dans l'aire de jeux. On n'a qu'à lire <i>l'ucoord(0)</i> avec <b>0 snake @</b>, convertir
 cette valeur en couple <i>{x,y}</i> et ensuite faire la vérifaction <i>(x&gt;(play-width-1))||(y&gt;(play-height-1))</i> ce qui se traduit en Forth par:
 <b> play-height 1- u&gt; swap  play-width 1- u&gt; or</b>
 <table>
	 <tr><th>mot<br>exécuté</th><th>S:</th></tr>
	 <tr><td>0</td><td>0</td></tr>
	 <tr><td>snake</td><td>a-addr(0)</td></tr>
	 <tr><td>@</td><td>ucoord(0)</td></tr>
	 <tr><td>ucoord&gt;xy</td><td>y<br>x</td></tr>
	 <tr><td>play-height</td><td>22<br>y<br>x</td></tr>
	 <tr><td>1-</td><td>21<br>y<br>x</td></tr>
	 <tr><td>u&gt;</td><td>f<br>x</td></tr>
	 <tr><td>swap</td><td>x<br>f</td></tr>
	 <tr><td>play-width</td><td>62<br>x<br>f</td></tr>
	 <tr><td>1-</td><td>61<br>x<br>f</td></tr>
	 <tr><td>U&gt;</td><td>f<br>f</td></tr>
	 <tr><td>or</td><td>f</td></tr>
 </table>
</p>
<p> Je vais en profiter ici pour faire la distinction entre les mots qui opèrent sur des entiers et commencent par la lettre <b>u</b> et les autres. Ceux qui
commecent par un <b>u</b> considèrent les entiers comme <b>non signés.</b> Voici un exemple:<br>
<b>-3 3 &gt; \ retourne FALSE</b><br>
<b>-3 3 ugt; \ retourne TRUE</b><br>
Parce Forth utilise l'arithmétique en complément de 2, les nombres négatifs sont représentés par tous les entiers dont le bit le plus significatif est à
1. Lar représentation binaire de <b>-3</b> est <b>0b1111111111111101</b> or cette série de bits si on la considère  comme un nombre non signé donne la valeur
<b>65533</b> ce qui est évidemment plus grand que 3.  Vous pouvez le vérifier simplement en entrant sur la ligne de comamnde la phrase suivante:<br>
<b>-3 u.</b>.  Le mot <b>u.</b> imprime l'entier au sommet de la pile comme le mot <b>.</b> sauf qu'il considère ce nombre comme étant non signé. 
</p>
<p>Donc lorsqu'on veut vérifier s'il y a eu collision, quoi de plus logique que de définir le mot <b>collision?</b> dont la définition est très simple:
<b>snake-bite? wall-bang? or</b> qui va retourné vrai si l'un ou l'autre de ces événement c'est produit. 
</p>
<p> Lorsque le serpent a gobé une pastille il faut augmenter le pointage mais on spécifier dans les règles du jeu que celui-ci dépend de la position de la
pastille, 4 points si elle est dans un coin, <b>in-corner?</b>, 2 points si elle est le long d'un mur <b>on-wall?</b>. Ces 2 mots prennent en argument 
la valeur <i>ucoord</i> de la pastille et retourne un indicateur booléen <i>f</i>. En <b>C</b> L'expression pour déterminer si la pastille est dans un coin
serait <br><b>(((y==0)||(y==(play-height-1))) && ((x==0)||(x==(play-width-1))))  </b><br>On commence par convertir <i>u</i> en couple <i>{x,y}</i>. 
Ensuite on effectue les comparaisons<br>
pour <i>y</i> on a <b>dup 0= swap play-height 1- = or \ s: x f </b><br>
pour <i>x</i> on a <b>swap dup 0= swap play-width 1- = or \ s: f f </b>
les 2 conditions doivent-être vrai en même temps donc on conclu par un <b>and</b>.
<table>
	<tr><th>mot<br>exécuté</th><th>S:</th></tr>
	<tr><td>ucoord&gt;xy</td><td>y<br>x</td></tr>
	<tr><td>dup</td><td>y<br>y<br>x</td></tr>
	<tr><td>0=</td><td>f<br>y<br>x</td></tr>
	<tr><td>swap</td><td>y<br>f<br>x</td></tr>
	<tr><td>play-height</td><td>22<br>y<br>f<br>x</td></tr>
	<tr><td>1-</td><td>21<br>y<br>f<br>x</td></tr>
	<tr><td>=</td><td>f<br>f<br>x</td></tr>
	<tr><td>or</td><td>f<br>x</td></tr>
	<tr><td>swap</td><td>x<br>f</td></tr>
	<tr><td>dup</td><td>x<br>x<br>f</td></tr>
	<tr><td>0=</td><td>f<br>x<br>f</td></tr>
	<tr><td>swap</td><td>x<br>f<br>f</td></tr>
	<tr><td>play-width</td><td>62<br>x<br>f<br>f</td></tr>
	<tr><td>1-</td><td>61<br>x<br>f<br>f</td></tr>
	<tr><td>=</td><td>f<br>f<br>f</td></tr>
	<tr><td>or</td><td>f<br>f</td></tr>
	<tr><td>and</td><td>f</td></tr>
</table>
<b></b>
</p>
<p>
	Le mot <b>on-wall?</b> fait la vérification <i>pastille le long du mur?</i>. Ici je vais présenter l'évolution de la pile des arguments par 
	des commentaires plutôt que par une table. C'est cette façon de faire qu'on utilise lorsqu'on programme et que
	l'état est la pile est trop complexe pour être mémorisée.<br>
	<b>ucoord&gt;xy \ s: x y</b><br>
	<b>dup \ s: x y y</b><br>
	<b>0= \ s: x y f</b><br>
	<b>swap \ s: x f y </b><br>
	<b>play-height \ x f y 22</b><br>
	<b>1- \ s: x f y 21</b><br>
	<b>= \ s: x f f</b><br>
	<b>or \ s: x f</b><br>
	<b>swap \ s: f x</b><br>
	<b>dup \ s: f x x</b><br>
	<b>0= \ s: f x f</b><br>
	<b>swap \ s: f f x</b><br>
	<b>play-width \ s: f f x 62</b><br>
	<b>1- \ s: f f x 61</b><br>
	<b>= \ s: f f f</b><br>
	<b>or \ s: f f</b><br>
	<b>or \ s: f</b><br>
</p>
<h3>Factorisation</h3>
<p>C'est le bon moment pour introduire la notion de <b>factorisation</b>. Si vous regardez la définition des mots <b>in-corner?</b> et <b>on-wall?</b>
elles sont identique sauf pour le dernier mot qui est <b>and</b> dans le premier cas et <b>or</b> dans le deuxième. Nous allons éliminer ce dédoublement
en créant un nouveau mot qui exécute le code commun au 2 définitions et redéfinir <b>in-corner?</b> ainsi que <b>on-wall?</b>. Notre nouveau mot est
<b>borders?</b><br>
<textarea id="code" style="height:200px;">
	\ retourne un indicateur pour chaque
	\ coordonnee, vrai signifie que la
	\ coordonnée longe le mur.
	: borders? ( u -- f f )
	  ucoord&gt;xy \ s: x y 
	  dup 0= \ s: x y f
	  swap \ s: x f y
	  play-height 1- = \ s: x f f
	  or swap \ s: f x
	  dup 0= \ s: f x f
	  swap \ s: f f x
	  play-width 1- = s:\ f f f
	  or ; \ s: f f  
</textarea><br>
	L'indicateur au sommet de la pile est <b>VRAI</b>  si la coordonnée <i>x</i> est le long d'un mur vertical. Le second indicateur est <b>VRAI</b> si la 
	coordonnée <i>y</i> est le long d'un mur horisontal. Si les 2 coordonnées sont le long d'un mur la pastille est forcément dans un coin on redéfinie donc
	<b>in-corner?</b><br>
	<textarea id="code">
		: in-corner? ( u -- f )
		  borders? and ; 
	</textarea><br>Pour que la condition <b>on-wall?</b> soit vrai il suffit que <i>x</i> ou <i>y</i> soit le long d'un mur, donc:<br>
	<textarea id="code">
		: on-wall? ( u -- f )
		borders? or ;
	</textarea><br>
	Ce procédé de mise en commun s'appelle factorisation et permet d'optimiser la taille du programme.
</p>
<p>
	On peut maintenant définir le mot <b>score+</b> qui sert à ajuster le pointage chaque fois que le serpent avale la pastille.
	<br><textarea id="code" style="height:150px;">
		\ si borders? retourne 2 indicateurs vrai
		\ c'est que la pastille est dans un coin.
		: score+ ( -- )
			1 food @ borders? \ s: 1 fy fx
			if swap 2* swap then \ si x le long d'un mur
			if 2* then \ si y le long d'un mur
			score +! 0 food ! ;
	</textarea><br>
	Après avoir factorisé <i>in-corner?</i> et <i>on-wall?</i> j'ai réalisé que grâce à <b>borders?</b> qui retourne 2 indicateurs booléens non seulement on
	n'a plus besoin des mots <b>in-corner?</b> et <b>on-wall?</b> mais  le mot <b>score+</b> peut-être redéfinie plus simplement. On commence par accordé 
	1 point ensuite on vérifie si la pastille est le long des murs avec la phrase <b>food @ borders?</b> puis pour chaque indicateur booléen retourné par 
	<b>borders?</b> qui est vrai on multiplie le score par 2. Donc si un seul des indicateur est vrai on obtient 2 points mais si les 2 sont vrai on 
	obtient 4 points. La factorisation nous a fait sauver encore plus de code que je l'envisageais au départ.
</p>
<p> Lorsque le serpent avale une pastille en plus d'augmenter le pointage il faut aussi ajouter un anneau au serpent. Le mot <b>snake+</b> accomplie cette
tâche.<br>
<textarea id="code" style="height:150px;">
	\ rallonge le serpent
	: snake+ ( -- )
		snake-len dup >r  \ s: a-addr  r: a-addr
		@ dup 1+ \ s: n n+1 r: a-addr 
		r> ! \ s: n r:  nouvelle valeur de snake-len sauvegardée.
		tail @  swap \ s: ucoord n
		snake ! ; \ s: ucoord du nouvel anneau sauvegardée.
</textarea> <br>
	<b>snake-len</b> est la variable qui contient la  longueur du serpent. On doit incrémenter cette valeur de 1. On envoie une copie de l'adresse de
	cette variable sur la pile des retours car on doit lire sa valeur et après l'avoir incrémentée il faut sauvegarder la nouvelle valeur. Bien sur on
	aurait pu simplement invoqué <b>snake-len</b> 2 fois mais cette façon de faire monte comment on peut utiliser les mots <b>&gt;R</b> et <b>R&gt;</b>
	pour sauvegarder temporairement une valeur sur la pile des retours pour accéder plus facilement les autres variables locales. Voici la version 
	simplifiée de ce mot:<br>
	<textarea id="code" style="height:200px;">
		\ rallonge le serpent
		: snake+ ( -- )
			snake-len @ \ s: n
			dup 1+ \ s: n n+1
			snake-len \ s: n n+1 a-addr
			! \ s: n  nouvelle valeur de snake-len sauvegardée.
			tail @  \ s: n u
			swap \ s: u n
			snake \ s: u a-addr(n)
			!  ; \ s: ucoord du nouvel anneau sauvegardée.
	</textarea><br>
	Ces deux définitions de <b>snake+</b> font exactement la même chose mais en procédent différemment.
	Rappellons-nous que la variable <b>tail</b> contient <i>l'ucoord</i> du dernier anneau du serpent avant l'exécution de <b>move-snake</b>.
	Lorsqu'on rallonge le serpent le nouvel anneau occupe cette position. 
</p>
<p> Le mot <b>eaten?</b> sert à vérifier si la pastille a été mangée par le serpent.<br>
<textarea id="code" style="height:150px;">
\ pastille mangee?
: eaten? ( -- f )
   0 snake @ \ s: u1
   food @ \ s: u1 u2
   = ; \ s: f  vrai si u1=u2
</textarea>
  Ce mot est très simple puisqu'il s'agit simple de comparer la position de la pastille conservée dans la variable <b>food</b> avec la position de la 
  tête du serpent qui est l'élément <b>0</b> de <b>snake</b>. Si les deux sont égales <b>eaten?</b> retourne vrai.
</p>
<p>
	<textarea id="code" style="height:200px;">
	\ lecture clavier touche 'q' quitte le jeu.
	: game-exit? ( -- f )
	   ekey? if ekey case
	   ar_left of head @ 1- 3 and head ! false endof
	   ar_right of head @ 1+ 3 and head ! false endof
	   'q' of true endof
	   'Q' of true endof
	   >r false r>
	   endcase else false then ;
</textarea><br>
	On doit faire une lecture du clavier. C'est le rôle du mot <b>game-exit?</b>. Il s'appelle ainsi car le joueur peut choisir de quitter la partie
	à n'importe quel moment en enfonçant la touche <b>Q</b>. <b>game-exit?</b> retourne <b>TRUE</b> si le joueur enfonce <b>Q</b> et <b>FALSE</b>
	autrement. Autrement que la touche <b>Q</b>, <b>game-exit?</b> ne reconnait que les touche <b>&larr;</b> et <b>&rarr;</b> qui font pivoter la
	tête du serpent vers la gauche ou la droite. On vérifie s'il y a une touche d'enfoncée avec <b>ekey?</b> et si c'est le cas on utilise <b>ekey</b>
	pour obtenir la valeur de cette touche et ensuite une structure <b>case ... endcase</b> déjà étudiée pour décider de l'action à accomplir. 
	S'il n'y pas de touche enfoncée on retourne simplement <b>FALSE</b>. Notez que le <b>q</b> est accepté aussi bien que le <b>Q</b>. 
	Les deux retourne <b>TRUE</b> pour indiquer que le joueur veut quitter la partie.
	
</p>
<p>Tous les mots nécessaire à l'exécution du jeu sont maintenant définis. La partie elle-même s'exécute à l'intérieur du mot <b>game-loop</b>.<br>
<textarea id="code" style="height:250px;">
	\ boucle du jeu
	: game-loop ( -- )
	  begin
	  speed ms \ délais vitesse serpent.
	  status food @ -1 = if new-food then draw-food
	  game-exit? ?dup 0= if
	  move-snake eaten? if score+  snake+ false else
	  collision? then then until ;
</textarea><br>
  La boucle se déroule à l'intérieur d'une boucle <b>begin ... until</b>. On a déjà vu cette structure de contrôle. Cette boucle se répète tant que la
  valeur au sommet de la pile lorsqu'on arrive au mot <b>until</b> est fausse. <b>speed</b> est une constante qui contrôle la vitesse du serpent.
  au début de chaque boucle on affiche le <b>status</b>. Si <b>l'ucoord</b> est -1 ça signifit qu'il n'y pas de pastille de nourriture dans l'aire de
  jeux donc on en cré une nouvelle avec <b>new-food</b>. On affiche la pastille <b>draw-food</b>. on appelle le mot <b>game-exit?</b> qui fait une
  lecture du clavier et retourne un booléen. <b>?dup</b> est un mot qu'on a pas encore vue. Ce mot cré une copie de la valeur au sommet de la pile
  seulement si cette valeur est différent de <b>0</b>. Si cette valeur est nulle c'est que soit le joueur n'a pas enfoncer de touches ou bien il a
  enfoncée une touche autre que <b>Q</b>. Dans ce cas on déplace le serpent <b>move-snake</b>, on vérifie s'il a mangé la pastille <b>eaten?</b>.
  S'il a mangé la pastille on augmente le pointage <b>score+</b> et rallonge le serpent <b>snake+</b> autrement on vérifie s'il y eu <b>collision?</b>.
  Quel que soit le chemin parcouru on doit avoir au sommet de la pile un indicateur booléen lorsqu'on arrive à <b>until.</b>. Il y a deux <b>then</b>
  qui se suivent parce qu'il y a un deuxième <b>if</b> à l'intérieur du premier.
</p>
<p> Mais avant d'exécuter une partie il faut initialiser les variables avec le mot <b>game-init</b> qui appelle <b>snake-init</b>.
<br><textarea id="code" style="height:200px;">
	 \ initialisation du serpent
	: snake-init ( -- )
	   east head !
	   play-width 2/ play-height 2/ xy&gt;ucoord snake-len @ 0 do
	   dup i snake ! 1- loop drop ;

	\ initialisation du jeu
	: game-init ( -- )
	   srand 4 snake-len ! 0 score ! -1 food !
	   snake-init draw-walls ;
</textarea><br>
  <b>srand</b> initialise le générateur pseudo hasard (PRNG), c'est indispensable de le faire avant d'appeller <b>rand</b>, sinon ce dernier retourne
  toujours <b>0</b>. Ensuite on initialise la <b>snake-len</b> à <b>4</b>, <b>score</b> à <b>0</b> et <b>food</b> à <b>-1</b>. Ensuite on appelle 
  <b>snake-init</b> qui initialise <b>head</b> avec la constante <b>east</b> pour ensuite positionner le serpent au centre de l'écran.
</p>
<p>Il ne nous reste que deux petits mots à définir, <b>game-over</b> et <b>snake-run</b>. Le premier affiche un message pour demander au joueur
s'il veut vraiment quitter en enfonçant la touche <b>Q</b> ou bien jouer une autre partie en enfonçant n'importe qu'elle autre touche. <b>game-over</b>
retourne la valeur de la touche enfoncée c'est à l'intérieur de <b>snake-run</b> que la décision est prise.<br>
<textarea id="code" style="height:200px;">
	\ partie terminee
	: game-over ( -- )
	   1 24 at-xy s" game over <Q> leave" type key ;

	\ lance le jeux.
	: snake-run ( -- )
	   begin game-init game-loop game-over 'q' = until cls ;
</textarea><br>
</p>
<h3>Conclusion</h3>
<p>
</p>
</body>
</html>
	
